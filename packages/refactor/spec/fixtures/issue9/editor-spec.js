// Generated by CoffeeScript 1.7.1

/*
Copyright (c) 2014 GitHub Inc.
https://github.com/atom/atom/blob/master/LICENSE.md
 */
var clipboard;

clipboard = require('clipboard');

describe("Editor", function() {
  var buffer, convertToHardTabs, editor, lineLengths, _ref;
  _ref = [], buffer = _ref[0], editor = _ref[1], lineLengths = _ref[2];
  convertToHardTabs = function(buffer) {
    return buffer.setText(buffer.getText().replace(/[ ]{2}/g, "\t"));
  };
  beforeEach(function() {
    waitsForPromise(function() {
      return atom.project.open('sample.js', {
        autoIndent: false
      }).then(function(o) {
        return editor = o;
      });
    });
    runs(function() {
      buffer = editor.buffer;
      return lineLengths = buffer.getLines().map(function(line) {
        return line.length;
      });
    });
    return waitsForPromise(function() {
      return atom.packages.activatePackage('language-javascript');
    });
  });
  describe("when the editor is deserialized", function() {
    return it("restores selections and folds based on markers in the buffer", function() {
      var editor2;
      editor.setSelectedBufferRange([[1, 2], [3, 4]]);
      editor.addSelectionForBufferRange([[5, 6], [7, 5]], {
        reversed: true
      });
      editor.foldBufferRow(4);
      expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();
      editor2 = editor.testSerialization();
      expect(editor2.id).toBe(editor.id);
      expect(editor2.getBuffer().getPath()).toBe(editor.getBuffer().getPath());
      expect(editor2.getSelectedBufferRanges()).toEqual([[[1, 2], [3, 4]], [[5, 6], [7, 5]]]);
      expect(editor2.getSelection(1).isReversed()).toBeTruthy();
      expect(editor2.isFoldedAtBufferRow(4)).toBeTruthy();
      return editor2.destroy();
    });
  });
  describe("when the editor is constructed with an initialLine option", function() {
    return it("positions the cursor on the specified line", function() {
      editor = null;
      waitsForPromise(function() {
        return atom.workspace.open('sample.less', {
          initialLine: 5
        }).then(function(o) {
          return editor = o;
        });
      });
      return runs(function() {
        buffer = editor.buffer;
        expect(editor.getCursor().getBufferPosition().row).toEqual(5);
        return expect(editor.getCursor().getBufferPosition().column).toEqual(0);
      });
    });
  });
  describe("when the editor is constructed with an initialColumn option", function() {
    return it("positions the cursor on the specified column", function() {
      editor = null;
      waitsForPromise(function() {
        return atom.workspace.open('sample.less', {
          initialColumn: 8
        }).then(function(o) {
          return editor = o;
        });
      });
      return runs(function() {
        buffer = editor.buffer;
        expect(editor.getCursor().getBufferPosition().row).toEqual(0);
        return expect(editor.getCursor().getBufferPosition().column).toEqual(8);
      });
    });
  });
  describe(".copy()", function() {
    return it("returns a different edit session with the same initial state", function() {
      var editor2;
      editor.setSelectedBufferRange([[1, 2], [3, 4]]);
      editor.addSelectionForBufferRange([[5, 6], [7, 8]], {
        reversed: true
      });
      editor.foldBufferRow(4);
      expect(editor.isFoldedAtBufferRow(4)).toBeTruthy();
      editor2 = editor.copy();
      expect(editor2.id).not.toBe(editor.id);
      expect(editor2.getSelectedBufferRanges()).toEqual(editor.getSelectedBufferRanges());
      expect(editor2.getSelection(1).isReversed()).toBeTruthy();
      expect(editor2.isFoldedAtBufferRow(4)).toBeTruthy();
      editor2.getSelection().setBufferRange([[2, 1], [4, 3]]);
      expect(editor2.getSelectedBufferRanges()).not.toEqual(editor.getSelectedBufferRanges());
      editor2.unfoldBufferRow(4);
      return expect(editor2.isFoldedAtBufferRow(4)).not.toBe(editor.isFoldedAtBufferRow(4));
    });
  });
  describe("config defaults", function() {
    return it("uses the `editor.tabLength`, `editor.softWrap`, and `editor.softTabs` config values", function() {
      var editor1, editor2;
      editor1 = null;
      editor2 = null;
      atom.config.set('editor.tabLength', 4);
      atom.config.set('editor.softWrap', true);
      atom.config.set('editor.softTabs', false);
      waitsForPromise(function() {
        return atom.workspace.open('a').then(function(o) {
          return editor1 = o;
        });
      });
      runs(function() {
        expect(editor1.getTabLength()).toBe(4);
        expect(editor1.getSoftWrap()).toBe(true);
        expect(editor1.getSoftTabs()).toBe(false);
        atom.config.set('editor.tabLength', 100);
        atom.config.set('editor.softWrap', false);
        return atom.config.set('editor.softTabs', true);
      });
      waitsForPromise(function() {
        return atom.workspace.open('b').then(function(o) {
          return editor2 = o;
        });
      });
      return runs(function() {
        expect(editor2.getTabLength()).toBe(100);
        expect(editor2.getSoftWrap()).toBe(false);
        return expect(editor2.getSoftTabs()).toBe(true);
      });
    });
  });
  describe("title", function() {
    describe(".getTitle()", function() {
      return it("uses the basename of the buffer's path as its title, or 'untitled' if the path is undefined", function() {
        expect(editor.getTitle()).toBe('sample.js');
        buffer.setPath(void 0);
        return expect(editor.getTitle()).toBe('untitled');
      });
    });
    describe(".getLongTitle()", function() {
      return it("appends the name of the containing directory to the basename of the file", function() {
        expect(editor.getLongTitle()).toBe('sample.js - fixtures');
        buffer.setPath(void 0);
        return expect(editor.getLongTitle()).toBe('untitled');
      });
    });
    return it("emits 'title-changed' events when the underlying buffer path", function() {
      var titleChangedHandler;
      titleChangedHandler = jasmine.createSpy("titleChangedHandler");
      editor.on('title-changed', titleChangedHandler);
      buffer.setPath('/foo/bar/baz.txt');
      buffer.setPath(void 0);
      return expect(titleChangedHandler.callCount).toBe(2);
    });
  });
  describe("cursor", function() {
    describe(".getCursor()", function() {
      return it("returns the most recently created cursor", function() {
        var lastCursor;
        editor.addCursorAtScreenPosition([1, 0]);
        lastCursor = editor.addCursorAtScreenPosition([2, 0]);
        return expect(editor.getCursor()).toBe(lastCursor);
      });
    });
    describe("when the cursor moves", function() {
      it("clears a goal column established by vertical movement", function() {
        editor.setText('b');
        editor.setCursorBufferPosition([0, 0]);
        editor.insertNewline();
        editor.moveCursorUp();
        editor.insertText('a');
        editor.moveCursorDown();
        return expect(editor.getCursorBufferPosition()).toEqual([1, 1]);
      });
      return it("emits a single 'cursors-moved' event for all moved cursors", function() {
        var cursorsMovedHandler;
        editor.on('cursors-moved', cursorsMovedHandler = jasmine.createSpy("cursorsMovedHandler"));
        editor.moveCursorDown();
        expect(cursorsMovedHandler.callCount).toBe(1);
        cursorsMovedHandler.reset();
        editor.addCursorAtScreenPosition([3, 0]);
        editor.moveCursorDown();
        expect(cursorsMovedHandler.callCount).toBe(1);
        cursorsMovedHandler.reset();
        editor.getCursor().moveDown();
        return expect(cursorsMovedHandler.callCount).toBe(1);
      });
    });
    describe(".setCursorScreenPosition(screenPosition)", function() {
      it("clears a goal column established by vertical movement", function() {
        editor.setCursorScreenPosition({
          row: 3,
          column: lineLengths[3]
        });
        editor.moveCursorDown();
        expect(editor.getCursorScreenPosition().column).not.toBe(6);
        editor.setCursorScreenPosition([4, 6]);
        expect(editor.getCursorScreenPosition().column).toBe(6);
        editor.moveCursorDown();
        return expect(editor.getCursorScreenPosition().column).toBe(6);
      });
      it("merges multiple cursors", function() {
        var cursor1, cursor2, _ref1;
        editor.setCursorScreenPosition([0, 0]);
        editor.addCursorAtScreenPosition([0, 1]);
        _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
        editor.setCursorScreenPosition([4, 7]);
        expect(editor.getCursors().length).toBe(1);
        expect(editor.getCursors()).toEqual([cursor1]);
        return expect(editor.getCursorScreenPosition()).toEqual([4, 7]);
      });
      return describe("when soft-wrap is enabled and code is folded", function() {
        beforeEach(function() {
          editor.setSoftWrap(true);
          editor.setEditorWidthInChars(50);
          return editor.createFold(2, 3);
        });
        return it("positions the cursor at the buffer position that corresponds to the given screen position", function() {
          editor.setCursorScreenPosition([9, 0]);
          return expect(editor.getCursorBufferPosition()).toEqual([8, 11]);
        });
      });
    });
    describe(".moveCursorUp()", function() {
      it("moves the cursor up", function() {
        editor.setCursorScreenPosition([2, 2]);
        editor.moveCursorUp();
        return expect(editor.getCursorScreenPosition()).toEqual([1, 2]);
      });
      it("retains the goal column across lines of differing length", function() {
        expect(lineLengths[6]).toBeGreaterThan(32);
        editor.setCursorScreenPosition({
          row: 6,
          column: 32
        });
        editor.moveCursorUp();
        expect(editor.getCursorScreenPosition().column).toBe(lineLengths[5]);
        editor.moveCursorUp();
        expect(editor.getCursorScreenPosition().column).toBe(lineLengths[4]);
        editor.moveCursorUp();
        return expect(editor.getCursorScreenPosition().column).toBe(32);
      });
      describe("when the cursor is on the first line", function() {
        return it("moves the cursor to the beginning of the line, but retains the goal column", function() {
          editor.setCursorScreenPosition([0, 4]);
          editor.moveCursorUp();
          expect(editor.getCursorScreenPosition()).toEqual([0, 0]);
          editor.moveCursorDown();
          return expect(editor.getCursorScreenPosition()).toEqual([1, 4]);
        });
      });
      describe("when there is a selection", function() {
        beforeEach(function() {
          return editor.setSelectedBufferRange([[4, 9], [5, 10]]);
        });
        return it("moves above the selection", function() {
          var cursor;
          cursor = editor.getCursor();
          editor.moveCursorUp();
          return expect(cursor.getBufferPosition()).toEqual([3, 9]);
        });
      });
      return it("merges cursors when they overlap", function() {
        var cursor1, cursor2, _ref1;
        editor.addCursorAtScreenPosition([1, 0]);
        _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
        editor.moveCursorUp();
        expect(editor.getCursors()).toEqual([cursor1]);
        return expect(cursor1.getBufferPosition()).toEqual([0, 0]);
      });
    });
    describe(".moveCursorDown()", function() {
      it("moves the cursor down", function() {
        editor.setCursorScreenPosition([2, 2]);
        editor.moveCursorDown();
        return expect(editor.getCursorScreenPosition()).toEqual([3, 2]);
      });
      it("retains the goal column across lines of differing length", function() {
        editor.setCursorScreenPosition({
          row: 3,
          column: lineLengths[3]
        });
        editor.moveCursorDown();
        expect(editor.getCursorScreenPosition().column).toBe(lineLengths[4]);
        editor.moveCursorDown();
        expect(editor.getCursorScreenPosition().column).toBe(lineLengths[5]);
        editor.moveCursorDown();
        return expect(editor.getCursorScreenPosition().column).toBe(lineLengths[3]);
      });
      describe("when the cursor is on the last line", function() {
        it("moves the cursor to the end of line, but retains the goal column when moving back up", function() {
          var lastLine, lastLineIndex;
          lastLineIndex = buffer.getLines().length - 1;
          lastLine = buffer.lineForRow(lastLineIndex);
          expect(lastLine.length).toBeGreaterThan(0);
          editor.setCursorScreenPosition({
            row: lastLineIndex,
            column: editor.getTabLength()
          });
          editor.moveCursorDown();
          expect(editor.getCursorScreenPosition()).toEqual({
            row: lastLineIndex,
            column: lastLine.length
          });
          editor.moveCursorUp();
          return expect(editor.getCursorScreenPosition().column).toBe(editor.getTabLength());
        });
        return it("retains a goal column of 0 when moving back up", function() {
          var lastLine, lastLineIndex;
          lastLineIndex = buffer.getLines().length - 1;
          lastLine = buffer.lineForRow(lastLineIndex);
          expect(lastLine.length).toBeGreaterThan(0);
          editor.setCursorScreenPosition({
            row: lastLineIndex,
            column: 0
          });
          editor.moveCursorDown();
          editor.moveCursorUp();
          return expect(editor.getCursorScreenPosition().column).toBe(0);
        });
      });
      describe("when there is a selection", function() {
        beforeEach(function() {
          return editor.setSelectedBufferRange([[4, 9], [5, 10]]);
        });
        return it("moves below the selection", function() {
          var cursor;
          cursor = editor.getCursor();
          editor.moveCursorDown();
          return expect(cursor.getBufferPosition()).toEqual([6, 10]);
        });
      });
      return it("merges cursors when they overlap", function() {
        var cursor1, cursor2, _ref1;
        editor.setCursorScreenPosition([12, 2]);
        editor.addCursorAtScreenPosition([11, 2]);
        _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
        editor.moveCursorDown();
        expect(editor.getCursors()).toEqual([cursor1]);
        return expect(cursor1.getBufferPosition()).toEqual([12, 2]);
      });
    });
    describe(".moveCursorLeft()", function() {
      it("moves the cursor by one column to the left", function() {
        editor.setCursorScreenPosition([1, 8]);
        editor.moveCursorLeft();
        return expect(editor.getCursorScreenPosition()).toEqual([1, 7]);
      });
      describe("when the cursor is in the first column", function() {
        describe("when there is a previous line", function() {
          return it("wraps to the end of the previous line", function() {
            editor.setCursorScreenPosition({
              row: 1,
              column: 0
            });
            editor.moveCursorLeft();
            return expect(editor.getCursorScreenPosition()).toEqual({
              row: 0,
              column: buffer.lineForRow(0).length
            });
          });
        });
        return describe("when the cursor is on the first line", function() {
          return it("remains in the same position (0,0)", function() {
            editor.setCursorScreenPosition({
              row: 0,
              column: 0
            });
            editor.moveCursorLeft();
            return expect(editor.getCursorScreenPosition()).toEqual({
              row: 0,
              column: 0
            });
          });
        });
      });
      describe("when softTabs is enabled and the cursor is preceded by leading whitespace", function() {
        return it("skips tabLength worth of whitespace at a time", function() {
          editor.setCursorBufferPosition([5, 6]);
          editor.moveCursorLeft();
          return expect(editor.getCursorBufferPosition()).toEqual([5, 4]);
        });
      });
      describe("when there is a selection", function() {
        beforeEach(function() {
          return editor.setSelectedBufferRange([[5, 22], [5, 27]]);
        });
        return it("moves to the left of the selection", function() {
          var cursor;
          cursor = editor.getCursor();
          editor.moveCursorLeft();
          expect(cursor.getBufferPosition()).toEqual([5, 22]);
          editor.moveCursorLeft();
          return expect(cursor.getBufferPosition()).toEqual([5, 21]);
        });
      });
      return it("merges cursors when they overlap", function() {
        var cursor1, cursor2, _ref1;
        editor.setCursorScreenPosition([0, 0]);
        editor.addCursorAtScreenPosition([0, 1]);
        _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
        editor.moveCursorLeft();
        expect(editor.getCursors()).toEqual([cursor1]);
        return expect(cursor1.getBufferPosition()).toEqual([0, 0]);
      });
    });
    describe(".moveCursorRight()", function() {
      it("moves the cursor by one column to the right", function() {
        editor.setCursorScreenPosition([3, 3]);
        editor.moveCursorRight();
        return expect(editor.getCursorScreenPosition()).toEqual([3, 4]);
      });
      describe("when the cursor is on the last column of a line", function() {
        describe("when there is a subsequent line", function() {
          return it("wraps to the beginning of the next line", function() {
            editor.setCursorScreenPosition([0, buffer.lineForRow(0).length]);
            editor.moveCursorRight();
            return expect(editor.getCursorScreenPosition()).toEqual([1, 0]);
          });
        });
        return describe("when the cursor is on the last line", function() {
          return it("remains in the same position", function() {
            var lastLine, lastLineIndex, lastPosition;
            lastLineIndex = buffer.getLines().length - 1;
            lastLine = buffer.lineForRow(lastLineIndex);
            expect(lastLine.length).toBeGreaterThan(0);
            lastPosition = {
              row: lastLineIndex,
              column: lastLine.length
            };
            editor.setCursorScreenPosition(lastPosition);
            editor.moveCursorRight();
            return expect(editor.getCursorScreenPosition()).toEqual(lastPosition);
          });
        });
      });
      describe("when there is a selection", function() {
        beforeEach(function() {
          return editor.setSelectedBufferRange([[5, 22], [5, 27]]);
        });
        return it("moves to the left of the selection", function() {
          var cursor;
          cursor = editor.getCursor();
          editor.moveCursorRight();
          expect(cursor.getBufferPosition()).toEqual([5, 27]);
          editor.moveCursorRight();
          return expect(cursor.getBufferPosition()).toEqual([5, 28]);
        });
      });
      return it("merges cursors when they overlap", function() {
        var cursor1, cursor2, _ref1;
        editor.setCursorScreenPosition([12, 2]);
        editor.addCursorAtScreenPosition([12, 1]);
        _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
        editor.moveCursorRight();
        expect(editor.getCursors()).toEqual([cursor1]);
        return expect(cursor1.getBufferPosition()).toEqual([12, 2]);
      });
    });
    describe(".moveCursorToTop()", function() {
      return it("moves the cursor to the top of the buffer", function() {
        editor.setCursorScreenPosition([11, 1]);
        editor.addCursorAtScreenPosition([12, 0]);
        editor.moveCursorToTop();
        expect(editor.getCursors().length).toBe(1);
        return expect(editor.getCursorBufferPosition()).toEqual([0, 0]);
      });
    });
    describe(".moveCursorToBottom()", function() {
      return it("moves the cusor to the bottom of the buffer", function() {
        editor.setCursorScreenPosition([0, 0]);
        editor.addCursorAtScreenPosition([1, 0]);
        editor.moveCursorToBottom();
        expect(editor.getCursors().length).toBe(1);
        return expect(editor.getCursorBufferPosition()).toEqual([12, 2]);
      });
    });
    describe(".moveCursorToBeginningOfScreenLine()", function() {
      describe("when soft wrap is on", function() {
        return it("moves cursor to the beginning of the screen line", function() {
          var cursor;
          editor.setSoftWrap(true);
          editor.setEditorWidthInChars(10);
          editor.setCursorScreenPosition([1, 2]);
          editor.moveCursorToBeginningOfScreenLine();
          cursor = editor.getCursor();
          return expect(cursor.getScreenPosition()).toEqual([1, 0]);
        });
      });
      return describe("when soft wrap is off", function() {
        return it("moves cursor to the beginning of then line", function() {
          var cursor1, cursor2, _ref1;
          editor.setCursorScreenPosition([0, 5]);
          editor.addCursorAtScreenPosition([1, 7]);
          editor.moveCursorToBeginningOfScreenLine();
          expect(editor.getCursors().length).toBe(2);
          _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
          expect(cursor1.getBufferPosition()).toEqual([0, 0]);
          return expect(cursor2.getBufferPosition()).toEqual([1, 0]);
        });
      });
    });
    describe(".moveCursorToEndOfScreenLine()", function() {
      describe("when soft wrap is on", function() {
        return it("moves cursor to the beginning of the screen line", function() {
          var cursor;
          editor.setSoftWrap(true);
          editor.setEditorWidthInChars(10);
          editor.setCursorScreenPosition([1, 2]);
          editor.moveCursorToEndOfScreenLine();
          cursor = editor.getCursor();
          return expect(cursor.getScreenPosition()).toEqual([1, 9]);
        });
      });
      return describe("when soft wrap is off", function() {
        return it("moves cursor to the end of line", function() {
          var cursor1, cursor2, _ref1;
          editor.setCursorScreenPosition([0, 0]);
          editor.addCursorAtScreenPosition([1, 0]);
          editor.moveCursorToEndOfScreenLine();
          expect(editor.getCursors().length).toBe(2);
          _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
          expect(cursor1.getBufferPosition()).toEqual([0, 29]);
          return expect(cursor2.getBufferPosition()).toEqual([1, 30]);
        });
      });
    });
    describe(".moveCursorToBeginningOfLine()", function() {
      return it("moves cursor to the beginning of the buffer line", function() {
        var cursor;
        editor.setSoftWrap(true);
        editor.setEditorWidthInChars(10);
        editor.setCursorScreenPosition([1, 2]);
        editor.moveCursorToBeginningOfLine();
        cursor = editor.getCursor();
        return expect(cursor.getScreenPosition()).toEqual([0, 0]);
      });
    });
    describe(".moveCursorToEndOfLine()", function() {
      return it("moves cursor to the end of the buffer line", function() {
        var cursor;
        editor.setSoftWrap(true);
        editor.setEditorWidthInChars(10);
        editor.setCursorScreenPosition([0, 2]);
        editor.moveCursorToEndOfLine();
        cursor = editor.getCursor();
        return expect(cursor.getScreenPosition()).toEqual([3, 4]);
      });
    });
    describe(".moveCursorToFirstCharacterOfLine()", function() {
      describe("when soft wrap is on", function() {
        return it("moves to the first character of the current screen line or the beginning of the screen line if it's already on the first character", function() {
          var cursor1, cursor2, _ref1;
          editor.setSoftWrap(true);
          editor.setEditorWidthInChars(10);
          editor.setCursorScreenPosition([2, 5]);
          editor.addCursorAtScreenPosition([8, 7]);
          editor.moveCursorToFirstCharacterOfLine();
          _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
          expect(cursor1.getScreenPosition()).toEqual([2, 0]);
          expect(cursor2.getScreenPosition()).toEqual([8, 4]);
          editor.moveCursorToFirstCharacterOfLine();
          expect(cursor1.getScreenPosition()).toEqual([2, 0]);
          return expect(cursor2.getScreenPosition()).toEqual([8, 0]);
        });
      });
      return describe("when soft wrap is off", function() {
        it("moves to the first character of the current line or the beginning of the line if it's already on the first character", function() {
          var cursor1, cursor2, _ref1;
          editor.setCursorScreenPosition([0, 5]);
          editor.addCursorAtScreenPosition([1, 7]);
          editor.moveCursorToFirstCharacterOfLine();
          _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
          expect(cursor1.getBufferPosition()).toEqual([0, 0]);
          expect(cursor2.getBufferPosition()).toEqual([1, 2]);
          editor.moveCursorToFirstCharacterOfLine();
          expect(cursor1.getBufferPosition()).toEqual([0, 0]);
          return expect(cursor2.getBufferPosition()).toEqual([1, 0]);
        });
        return it("moves to the beginning of the line if it only contains whitespace ", function() {
          var cursor;
          editor.setText("first\n    \nthird");
          editor.setCursorScreenPosition([1, 2]);
          editor.moveCursorToFirstCharacterOfLine();
          cursor = editor.getCursor();
          return expect(cursor.getBufferPosition()).toEqual([1, 0]);
        });
      });
    });
    describe(".moveCursorToBeginningOfWord()", function() {
      it("moves the cursor to the beginning of the word", function() {
        var cursor1, cursor2, cursor3, _ref1;
        editor.setCursorBufferPosition([0, 8]);
        editor.addCursorAtBufferPosition([1, 12]);
        editor.addCursorAtBufferPosition([3, 0]);
        _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1], cursor3 = _ref1[2];
        editor.moveCursorToBeginningOfWord();
        expect(cursor1.getBufferPosition()).toEqual([0, 4]);
        expect(cursor2.getBufferPosition()).toEqual([1, 11]);
        return expect(cursor3.getBufferPosition()).toEqual([2, 39]);
      });
      it("does not fail at position [0, 0]", function() {
        editor.setCursorBufferPosition([0, 0]);
        return editor.moveCursorToBeginningOfWord();
      });
      it("treats lines with only whitespace as a word", function() {
        editor.setCursorBufferPosition([11, 0]);
        editor.moveCursorToBeginningOfWord();
        return expect(editor.getCursorBufferPosition()).toEqual([10, 0]);
      });
      return it("works when the current line is blank", function() {
        editor.setCursorBufferPosition([10, 0]);
        editor.moveCursorToBeginningOfWord();
        return expect(editor.getCursorBufferPosition()).toEqual([9, 2]);
      });
    });
    describe(".moveCursorToPreviousWordBoundary()", function() {
      return it("moves the cursor to the previous word boundary", function() {
        var cursor1, cursor2, cursor3, cursor4, _ref1;
        editor.setCursorBufferPosition([0, 8]);
        editor.addCursorAtBufferPosition([2, 0]);
        editor.addCursorAtBufferPosition([2, 4]);
        editor.addCursorAtBufferPosition([3, 14]);
        _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1], cursor3 = _ref1[2], cursor4 = _ref1[3];
        editor.moveCursorToPreviousWordBoundary();
        expect(cursor1.getBufferPosition()).toEqual([0, 4]);
        expect(cursor2.getBufferPosition()).toEqual([1, 30]);
        expect(cursor3.getBufferPosition()).toEqual([2, 0]);
        return expect(cursor4.getBufferPosition()).toEqual([3, 13]);
      });
    });
    describe(".moveCursorToNextWordBoundary()", function() {
      return it("moves the cursor to the previous word boundary", function() {
        var cursor1, cursor2, cursor3, cursor4, _ref1;
        editor.setCursorBufferPosition([0, 8]);
        editor.addCursorAtBufferPosition([2, 40]);
        editor.addCursorAtBufferPosition([3, 0]);
        editor.addCursorAtBufferPosition([3, 30]);
        _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1], cursor3 = _ref1[2], cursor4 = _ref1[3];
        editor.moveCursorToNextWordBoundary();
        expect(cursor1.getBufferPosition()).toEqual([0, 13]);
        expect(cursor2.getBufferPosition()).toEqual([3, 0]);
        expect(cursor3.getBufferPosition()).toEqual([3, 4]);
        return expect(cursor4.getBufferPosition()).toEqual([3, 31]);
      });
    });
    describe(".moveCursorToEndOfWord()", function() {
      it("moves the cursor to the end of the word", function() {
        var cursor1, cursor2, cursor3, _ref1;
        editor.setCursorBufferPosition([0, 6]);
        editor.addCursorAtBufferPosition([1, 10]);
        editor.addCursorAtBufferPosition([2, 40]);
        _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1], cursor3 = _ref1[2];
        editor.moveCursorToEndOfWord();
        expect(cursor1.getBufferPosition()).toEqual([0, 13]);
        expect(cursor2.getBufferPosition()).toEqual([1, 12]);
        return expect(cursor3.getBufferPosition()).toEqual([3, 7]);
      });
      it("does not blow up when there is no next word", function() {
        var endPosition;
        editor.setCursorBufferPosition([Infinity, Infinity]);
        endPosition = editor.getCursorBufferPosition();
        editor.moveCursorToEndOfWord();
        return expect(editor.getCursorBufferPosition()).toEqual(endPosition);
      });
      it("treats lines with only whitespace as a word", function() {
        editor.setCursorBufferPosition([9, 4]);
        editor.moveCursorToEndOfWord();
        return expect(editor.getCursorBufferPosition()).toEqual([10, 0]);
      });
      return it("works when the current line is blank", function() {
        editor.setCursorBufferPosition([10, 0]);
        editor.moveCursorToEndOfWord();
        return expect(editor.getCursorBufferPosition()).toEqual([11, 8]);
      });
    });
    describe(".moveCursorToBeginningOfNextWord()", function() {
      it("moves the cursor before the first character of the next word", function() {
        var cursor, cursor1, cursor2, cursor3, _ref1;
        editor.setCursorBufferPosition([0, 6]);
        editor.addCursorAtBufferPosition([1, 11]);
        editor.addCursorAtBufferPosition([2, 0]);
        _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1], cursor3 = _ref1[2];
        editor.moveCursorToBeginningOfNextWord();
        expect(cursor1.getBufferPosition()).toEqual([0, 14]);
        expect(cursor2.getBufferPosition()).toEqual([1, 13]);
        expect(cursor3.getBufferPosition()).toEqual([2, 4]);
        editor.setText("ab cde- ");
        editor.setCursorBufferPosition([0, 2]);
        cursor = editor.getCursor();
        editor.moveCursorToBeginningOfNextWord();
        return expect(cursor.getBufferPosition()).toEqual([0, 3]);
      });
      it("does not blow up when there is no next word", function() {
        var endPosition;
        editor.setCursorBufferPosition([Infinity, Infinity]);
        endPosition = editor.getCursorBufferPosition();
        editor.moveCursorToBeginningOfNextWord();
        return expect(editor.getCursorBufferPosition()).toEqual(endPosition);
      });
      it("treats lines with only whitespace as a word", function() {
        editor.setCursorBufferPosition([9, 4]);
        editor.moveCursorToBeginningOfNextWord();
        return expect(editor.getCursorBufferPosition()).toEqual([10, 0]);
      });
      return it("works when the current line is blank", function() {
        editor.setCursorBufferPosition([10, 0]);
        editor.moveCursorToBeginningOfNextWord();
        return expect(editor.getCursorBufferPosition()).toEqual([11, 9]);
      });
    });
    describe(".moveCursorToBeginningOfNextParagraph()", function() {
      return it("moves the cursor before the first line of the next paragraph", function() {
        var cursor;
        editor.setCursorBufferPosition([0, 6]);
        cursor = editor.getCursor();
        editor.moveCursorToBeginningOfNextParagraph();
        expect(cursor.getBufferPosition()).toEqual({
          row: 10,
          column: 0
        });
        editor.setText("");
        editor.setCursorBufferPosition([0, 0]);
        cursor = editor.getCursor();
        editor.moveCursorToBeginningOfNextParagraph();
        return expect(cursor.getBufferPosition()).toEqual([0, 0]);
      });
    });
    describe(".moveCursorToBeginningOfPreviousParagraph()", function() {
      return it("moves the cursor before the first line of the pevious paragraph", function() {
        var cursor;
        editor.setCursorBufferPosition([10, 0]);
        cursor = editor.getCursor();
        editor.moveCursorToBeginningOfPreviousParagraph();
        expect(cursor.getBufferPosition()).toEqual({
          row: 0,
          column: 0
        });
        editor.setText("");
        editor.setCursorBufferPosition([0, 0]);
        cursor = editor.getCursor();
        editor.moveCursorToBeginningOfPreviousParagraph();
        return expect(cursor.getBufferPosition()).toEqual([0, 0]);
      });
    });
    describe(".getCurrentParagraphBufferRange()", function() {
      return it("returns the buffer range of the current paragraph, delimited by blank lines or the beginning / end of the file", function() {
        buffer.setText("  I am the first paragraph,\nbordered by the beginning of\nthe file\n" + '   ' + "\n\n  I am the second paragraph\nwith blank lines above and below\nme.\n\nI am the last paragraph,\nbordered by the end of the file.");
        editor.setCursorBufferPosition([1, 7]);
        expect(editor.getCurrentParagraphBufferRange()).toEqual([[0, 0], [2, 8]]);
        editor.setCursorBufferPosition([7, 1]);
        expect(editor.getCurrentParagraphBufferRange()).toEqual([[5, 0], [7, 3]]);
        editor.setCursorBufferPosition([9, 10]);
        expect(editor.getCurrentParagraphBufferRange()).toEqual([[9, 0], [10, 32]]);
        editor.setCursorBufferPosition([3, 1]);
        return expect(editor.getCurrentParagraphBufferRange()).toBeUndefined();
      });
    });
    describe("cursor-moved events", function() {
      var cursorMovedHandler;
      cursorMovedHandler = null;
      beforeEach(function() {
        editor.foldBufferRow(4);
        editor.setSelectedBufferRange([[8, 1], [9, 0]]);
        cursorMovedHandler = jasmine.createSpy("cursorMovedHandler");
        return editor.on('cursor-moved', cursorMovedHandler);
      });
      describe("when the position of the cursor changes", function() {
        return it("emits a cursor-moved event", function() {
          buffer.insert([9, 0], '...');
          return expect(cursorMovedHandler).toHaveBeenCalledWith({
            oldBufferPosition: [9, 0],
            oldScreenPosition: [6, 0],
            newBufferPosition: [9, 3],
            newScreenPosition: [6, 3],
            textChanged: true
          });
        });
      });
      return describe("when the position of the associated selection's tail changes, but not the cursor's position", function() {
        return it("does not emit a cursor-moved event", function() {
          buffer.insert([8, 0], '...');
          return expect(cursorMovedHandler).not.toHaveBeenCalled();
        });
      });
    });
    describe("addCursorAtScreenPosition(screenPosition)", function() {
      return describe("when a cursor already exists at the position", function() {
        return it("returns the existing cursor", function() {
          var cursor1, cursor2;
          cursor1 = editor.addCursorAtScreenPosition([0, 2]);
          cursor2 = editor.addCursorAtScreenPosition([0, 2]);
          return expect(cursor2.marker).toBe(cursor1.marker);
        });
      });
    });
    describe("addCursorAtBufferPosition(bufferPosition)", function() {
      return describe("when a cursor already exists at the position", function() {
        return it("returns the existing cursor", function() {
          var cursor1, cursor2;
          cursor1 = editor.addCursorAtBufferPosition([1, 4]);
          cursor2 = editor.addCursorAtBufferPosition([1, 4]);
          return expect(cursor2.marker).toBe(cursor1.marker);
        });
      });
    });
    return describe("autoscroll", function() {
      beforeEach(function() {
        editor.manageScrollPosition = true;
        editor.setVerticalScrollMargin(2);
        editor.setHorizontalScrollMargin(2);
        editor.setLineHeightInPixels(10);
        editor.setDefaultCharWidth(10);
        editor.setHorizontalScrollbarHeight(0);
        editor.setHeight(5.5 * 10);
        return editor.setWidth(5.5 * 10);
      });
      it("scrolls down when the last cursor gets closer than ::verticalScrollMargin to the bottom of the editor", function() {
        expect(editor.getScrollTop()).toBe(0);
        expect(editor.getScrollBottom()).toBe(5.5 * 10);
        editor.setCursorScreenPosition([2, 0]);
        expect(editor.getScrollBottom()).toBe(5.5 * 10);
        editor.moveCursorDown();
        expect(editor.getScrollBottom()).toBe(6 * 10);
        editor.moveCursorDown();
        return expect(editor.getScrollBottom()).toBe(7 * 10);
      });
      it("scrolls up when the last cursor gets closer than ::verticalScrollMargin to the top of the editor", function() {
        editor.setCursorScreenPosition([11, 0]);
        editor.setScrollBottom(editor.getScrollHeight());
        editor.moveCursorUp();
        expect(editor.getScrollBottom()).toBe(editor.getScrollHeight());
        editor.moveCursorUp();
        expect(editor.getScrollTop()).toBe(7 * 10);
        editor.moveCursorUp();
        return expect(editor.getScrollTop()).toBe(6 * 10);
      });
      it("scrolls right when the last cursor gets closer than ::horizontalScrollMargin to the right of the editor", function() {
        expect(editor.getScrollLeft()).toBe(0);
        expect(editor.getScrollRight()).toBe(5.5 * 10);
        editor.setCursorScreenPosition([0, 2]);
        expect(editor.getScrollRight()).toBe(5.5 * 10);
        editor.moveCursorRight();
        expect(editor.getScrollRight()).toBe(6 * 10);
        editor.moveCursorRight();
        return expect(editor.getScrollRight()).toBe(7 * 10);
      });
      it("scrolls left when the last cursor gets closer than ::horizontalScrollMargin to the left of the editor", function() {
        editor.setScrollRight(editor.getScrollWidth());
        editor.setCursorScreenPosition([6, 62]);
        expect(editor.getScrollRight()).toBe(editor.getScrollWidth());
        editor.moveCursorLeft();
        expect(editor.getScrollLeft()).toBe(59 * 10);
        editor.moveCursorLeft();
        return expect(editor.getScrollLeft()).toBe(58 * 10);
      });
      it("scrolls down when inserting lines makes the document longer than the editor's height", function() {
        editor.setCursorScreenPosition([13, Infinity]);
        editor.insertNewline();
        expect(editor.getScrollBottom()).toBe(14 * 10);
        editor.insertNewline();
        return expect(editor.getScrollBottom()).toBe(15 * 10);
      });
      return it("autoscrolls to the cursor when it moves due to undo", function() {
        editor.insertText('abc');
        editor.setScrollTop(Infinity);
        editor.undo();
        return expect(editor.getScrollTop()).toBe(0);
      });
    });
  });
  describe("selection", function() {
    var selection;
    selection = null;
    beforeEach(function() {
      return selection = editor.getSelection();
    });
    describe(".selectUp/Down/Left/Right()", function() {
      it("expands each selection to its cursor's new location", function() {
        var selection1, selection2, _ref1;
        editor.setSelectedBufferRanges([[[0, 9], [0, 13]], [[3, 16], [3, 21]]]);
        _ref1 = editor.getSelections(), selection1 = _ref1[0], selection2 = _ref1[1];
        editor.selectRight();
        expect(selection1.getBufferRange()).toEqual([[0, 9], [0, 14]]);
        expect(selection2.getBufferRange()).toEqual([[3, 16], [3, 22]]);
        editor.selectLeft();
        editor.selectLeft();
        expect(selection1.getBufferRange()).toEqual([[0, 9], [0, 12]]);
        expect(selection2.getBufferRange()).toEqual([[3, 16], [3, 20]]);
        editor.selectDown();
        expect(selection1.getBufferRange()).toEqual([[0, 9], [1, 12]]);
        expect(selection2.getBufferRange()).toEqual([[3, 16], [4, 20]]);
        editor.selectUp();
        expect(selection1.getBufferRange()).toEqual([[0, 9], [0, 12]]);
        return expect(selection2.getBufferRange()).toEqual([[3, 16], [3, 20]]);
      });
      it("merges selections when they intersect when moving down", function() {
        var selection1, selection2, selection3, _ref1;
        editor.setSelectedBufferRanges([[[0, 9], [0, 13]], [[1, 10], [1, 20]], [[2, 15], [3, 25]]]);
        _ref1 = editor.getSelections(), selection1 = _ref1[0], selection2 = _ref1[1], selection3 = _ref1[2];
        editor.selectDown();
        expect(editor.getSelections()).toEqual([selection1]);
        expect(selection1.getScreenRange()).toEqual([[0, 9], [4, 25]]);
        return expect(selection1.isReversed()).toBeFalsy();
      });
      it("merges selections when they intersect when moving up", function() {
        var selection1, selection2, _ref1;
        editor.setSelectedBufferRanges([[[0, 9], [0, 13]], [[1, 10], [1, 20]]], {
          reversed: true
        });
        _ref1 = editor.getSelections(), selection1 = _ref1[0], selection2 = _ref1[1];
        editor.selectUp();
        expect(editor.getSelections().length).toBe(1);
        expect(editor.getSelections()).toEqual([selection1]);
        expect(selection1.getScreenRange()).toEqual([[0, 0], [1, 20]]);
        return expect(selection1.isReversed()).toBeTruthy();
      });
      it("merges selections when they intersect when moving left", function() {
        var selection1, selection2, _ref1;
        editor.setSelectedBufferRanges([[[0, 9], [0, 13]], [[0, 14], [1, 20]]], {
          reversed: true
        });
        _ref1 = editor.getSelections(), selection1 = _ref1[0], selection2 = _ref1[1];
        editor.selectLeft();
        expect(editor.getSelections()).toEqual([selection1]);
        expect(selection1.getScreenRange()).toEqual([[0, 8], [1, 20]]);
        return expect(selection1.isReversed()).toBeTruthy();
      });
      return it("merges selections when they intersect when moving right", function() {
        var selection1, selection2, _ref1;
        editor.setSelectedBufferRanges([[[0, 9], [0, 13]], [[0, 14], [1, 20]]]);
        _ref1 = editor.getSelections(), selection1 = _ref1[0], selection2 = _ref1[1];
        editor.selectRight();
        expect(editor.getSelections()).toEqual([selection1]);
        expect(selection1.getScreenRange()).toEqual([[0, 9], [1, 21]]);
        return expect(selection1.isReversed()).toBeFalsy();
      });
    });
    describe(".selectToScreenPosition(screenPosition)", function() {
      return it("expands the last selection to the given position", function() {
        var selection1, selection2, selections;
        editor.setSelectedBufferRange([[3, 0], [4, 5]]);
        editor.addCursorAtScreenPosition([5, 6]);
        editor.selectToScreenPosition([6, 2]);
        selections = editor.getSelections();
        expect(selections.length).toBe(2);
        selection1 = selections[0], selection2 = selections[1];
        expect(selection1.getScreenRange()).toEqual([[3, 0], [4, 5]]);
        return expect(selection2.getScreenRange()).toEqual([[5, 6], [6, 2]]);
      });
    });
    describe(".selectToBeginningOfNextParagraph()", function() {
      return it("selects from the cursor to first line of the next paragraph", function() {
        var selections;
        editor.setSelectedBufferRange([[3, 0], [4, 5]]);
        editor.addCursorAtScreenPosition([5, 6]);
        editor.selectToScreenPosition([6, 2]);
        editor.selectToBeginningOfNextParagraph();
        selections = editor.getSelections();
        expect(selections.length).toBe(1);
        return expect(selections[0].getScreenRange()).toEqual([[3, 0], [10, 0]]);
      });
    });
    describe(".selectToBeginningOfPreviousParagraph()", function() {
      it("selects from the cursor to the first line of the pevious paragraph", function() {
        var selections;
        editor.setSelectedBufferRange([[3, 0], [4, 5]]);
        editor.addCursorAtScreenPosition([5, 6]);
        editor.selectToScreenPosition([6, 2]);
        editor.selectToBeginningOfPreviousParagraph();
        selections = editor.getSelections();
        expect(selections.length).toBe(1);
        return expect(selections[0].getScreenRange()).toEqual([[0, 0], [5, 6]]);
      });
      return it("merges selections if they intersect, maintaining the directionality of the last selection", function() {
        var selection1, selections;
        editor.setCursorScreenPosition([4, 10]);
        editor.selectToScreenPosition([5, 27]);
        editor.addCursorAtScreenPosition([3, 10]);
        editor.selectToScreenPosition([6, 27]);
        selections = editor.getSelections();
        expect(selections.length).toBe(1);
        selection1 = selections[0];
        expect(selection1.getScreenRange()).toEqual([[3, 10], [6, 27]]);
        expect(selection1.isReversed()).toBeFalsy();
        editor.addCursorAtScreenPosition([7, 4]);
        editor.selectToScreenPosition([4, 11]);
        selections = editor.getSelections();
        expect(selections.length).toBe(1);
        selection1 = selections[0];
        expect(selection1.getScreenRange()).toEqual([[3, 10], [7, 4]]);
        return expect(selection1.isReversed()).toBeTruthy();
      });
    });
    describe(".selectToTop()", function() {
      return it("selects text from cusor position to the top of the buffer", function() {
        editor.setCursorScreenPosition([11, 2]);
        editor.addCursorAtScreenPosition([10, 0]);
        editor.selectToTop();
        expect(editor.getCursors().length).toBe(1);
        expect(editor.getCursorBufferPosition()).toEqual([0, 0]);
        expect(editor.getSelection().getBufferRange()).toEqual([[0, 0], [11, 2]]);
        return expect(editor.getSelection().isReversed()).toBeTruthy();
      });
    });
    describe(".selectToBottom()", function() {
      return it("selects text from cusor position to the bottom of the buffer", function() {
        editor.setCursorScreenPosition([10, 0]);
        editor.addCursorAtScreenPosition([9, 3]);
        editor.selectToBottom();
        expect(editor.getCursors().length).toBe(1);
        expect(editor.getCursorBufferPosition()).toEqual([12, 2]);
        expect(editor.getSelection().getBufferRange()).toEqual([[9, 3], [12, 2]]);
        return expect(editor.getSelection().isReversed()).toBeFalsy();
      });
    });
    describe(".selectAll()", function() {
      return it("selects the entire buffer", function() {
        editor.selectAll();
        return expect(editor.getSelection().getBufferRange()).toEqual(buffer.getRange());
      });
    });
    describe(".selectToBeginningOfLine()", function() {
      return it("selects text from cusor position to beginning of line", function() {
        var cursor1, cursor2, selection1, selection2, _ref1, _ref2;
        editor.setCursorScreenPosition([12, 2]);
        editor.addCursorAtScreenPosition([11, 3]);
        editor.selectToBeginningOfLine();
        expect(editor.getCursors().length).toBe(2);
        _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
        expect(cursor1.getBufferPosition()).toEqual([12, 0]);
        expect(cursor2.getBufferPosition()).toEqual([11, 0]);
        expect(editor.getSelections().length).toBe(2);
        _ref2 = editor.getSelections(), selection1 = _ref2[0], selection2 = _ref2[1];
        expect(selection1.getBufferRange()).toEqual([[12, 0], [12, 2]]);
        expect(selection1.isReversed()).toBeTruthy();
        expect(selection2.getBufferRange()).toEqual([[11, 0], [11, 3]]);
        return expect(selection2.isReversed()).toBeTruthy();
      });
    });
    describe(".selectToEndOfLine()", function() {
      return it("selects text from cusor position to end of line", function() {
        var cursor1, cursor2, selection1, selection2, _ref1, _ref2;
        editor.setCursorScreenPosition([12, 0]);
        editor.addCursorAtScreenPosition([11, 3]);
        editor.selectToEndOfLine();
        expect(editor.getCursors().length).toBe(2);
        _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
        expect(cursor1.getBufferPosition()).toEqual([12, 2]);
        expect(cursor2.getBufferPosition()).toEqual([11, 44]);
        expect(editor.getSelections().length).toBe(2);
        _ref2 = editor.getSelections(), selection1 = _ref2[0], selection2 = _ref2[1];
        expect(selection1.getBufferRange()).toEqual([[12, 0], [12, 2]]);
        expect(selection1.isReversed()).toBeFalsy();
        expect(selection2.getBufferRange()).toEqual([[11, 3], [11, 44]]);
        return expect(selection2.isReversed()).toBeFalsy();
      });
    });
    describe(".selectLine()", function() {
      return it("selects the entire line (including newlines) at given row", function() {
        editor.setCursorScreenPosition([1, 2]);
        editor.selectLine();
        expect(editor.getSelectedBufferRange()).toEqual([[1, 0], [2, 0]]);
        expect(editor.getSelectedText()).toBe("  var sort = function(items) {\n");
        editor.setCursorScreenPosition([12, 2]);
        editor.selectLine();
        expect(editor.getSelectedBufferRange()).toEqual([[12, 0], [12, 2]]);
        editor.setCursorBufferPosition([0, 2]);
        editor.selectLine();
        editor.selectLine();
        return expect(editor.getSelectedBufferRange()).toEqual([[0, 0], [2, 0]]);
      });
    });
    describe(".selectToBeginningOfWord()", function() {
      return it("selects text from cusor position to beginning of word", function() {
        var cursor1, cursor2, selection1, selection2, _ref1, _ref2;
        editor.setCursorScreenPosition([0, 13]);
        editor.addCursorAtScreenPosition([3, 49]);
        editor.selectToBeginningOfWord();
        expect(editor.getCursors().length).toBe(2);
        _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
        expect(cursor1.getBufferPosition()).toEqual([0, 4]);
        expect(cursor2.getBufferPosition()).toEqual([3, 47]);
        expect(editor.getSelections().length).toBe(2);
        _ref2 = editor.getSelections(), selection1 = _ref2[0], selection2 = _ref2[1];
        expect(selection1.getBufferRange()).toEqual([[0, 4], [0, 13]]);
        expect(selection1.isReversed()).toBeTruthy();
        expect(selection2.getBufferRange()).toEqual([[3, 47], [3, 49]]);
        return expect(selection2.isReversed()).toBeTruthy();
      });
    });
    describe(".selectToEndOfWord()", function() {
      return it("selects text from cusor position to end of word", function() {
        var cursor1, cursor2, selection1, selection2, _ref1, _ref2;
        editor.setCursorScreenPosition([0, 4]);
        editor.addCursorAtScreenPosition([3, 48]);
        editor.selectToEndOfWord();
        expect(editor.getCursors().length).toBe(2);
        _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
        expect(cursor1.getBufferPosition()).toEqual([0, 13]);
        expect(cursor2.getBufferPosition()).toEqual([3, 50]);
        expect(editor.getSelections().length).toBe(2);
        _ref2 = editor.getSelections(), selection1 = _ref2[0], selection2 = _ref2[1];
        expect(selection1.getBufferRange()).toEqual([[0, 4], [0, 13]]);
        expect(selection1.isReversed()).toBeFalsy();
        expect(selection2.getBufferRange()).toEqual([[3, 48], [3, 50]]);
        return expect(selection2.isReversed()).toBeFalsy();
      });
    });
    describe(".selectToBeginningOfNextWord()", function() {
      return it("selects text from cusor position to beginning of next word", function() {
        var cursor1, cursor2, selection1, selection2, _ref1, _ref2;
        editor.setCursorScreenPosition([0, 4]);
        editor.addCursorAtScreenPosition([3, 48]);
        editor.selectToBeginningOfNextWord();
        expect(editor.getCursors().length).toBe(2);
        _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
        expect(cursor1.getBufferPosition()).toEqual([0, 14]);
        expect(cursor2.getBufferPosition()).toEqual([3, 51]);
        expect(editor.getSelections().length).toBe(2);
        _ref2 = editor.getSelections(), selection1 = _ref2[0], selection2 = _ref2[1];
        expect(selection1.getBufferRange()).toEqual([[0, 4], [0, 14]]);
        expect(selection1.isReversed()).toBeFalsy();
        expect(selection2.getBufferRange()).toEqual([[3, 48], [3, 51]]);
        return expect(selection2.isReversed()).toBeFalsy();
      });
    });
    describe(".selectToPreviousWordBoundary()", function() {
      return it("select to the previous word boundary", function() {
        var selection1, selection2, selection3, selection4, _ref1;
        editor.setCursorBufferPosition([0, 8]);
        editor.addCursorAtBufferPosition([2, 0]);
        editor.addCursorAtBufferPosition([3, 4]);
        editor.addCursorAtBufferPosition([3, 14]);
        editor.selectToPreviousWordBoundary();
        expect(editor.getSelections().length).toBe(4);
        _ref1 = editor.getSelections(), selection1 = _ref1[0], selection2 = _ref1[1], selection3 = _ref1[2], selection4 = _ref1[3];
        expect(selection1.getBufferRange()).toEqual([[0, 8], [0, 4]]);
        expect(selection1.isReversed()).toBeTruthy();
        expect(selection2.getBufferRange()).toEqual([[2, 0], [1, 30]]);
        expect(selection2.isReversed()).toBeTruthy();
        expect(selection3.getBufferRange()).toEqual([[3, 4], [3, 0]]);
        expect(selection3.isReversed()).toBeTruthy();
        expect(selection4.getBufferRange()).toEqual([[3, 14], [3, 13]]);
        return expect(selection4.isReversed()).toBeTruthy();
      });
    });
    describe(".selectToNextWordBoundary()", function() {
      return it("select to the next word boundary", function() {
        var selection1, selection2, selection3, selection4, _ref1;
        editor.setCursorBufferPosition([0, 8]);
        editor.addCursorAtBufferPosition([2, 40]);
        editor.addCursorAtBufferPosition([4, 0]);
        editor.addCursorAtBufferPosition([3, 30]);
        editor.selectToNextWordBoundary();
        expect(editor.getSelections().length).toBe(4);
        _ref1 = editor.getSelections(), selection1 = _ref1[0], selection2 = _ref1[1], selection3 = _ref1[2], selection4 = _ref1[3];
        expect(selection1.getBufferRange()).toEqual([[0, 8], [0, 13]]);
        expect(selection1.isReversed()).toBeFalsy();
        expect(selection2.getBufferRange()).toEqual([[2, 40], [3, 0]]);
        expect(selection2.isReversed()).toBeFalsy();
        expect(selection3.getBufferRange()).toEqual([[4, 0], [4, 4]]);
        expect(selection3.isReversed()).toBeFalsy();
        expect(selection4.getBufferRange()).toEqual([[3, 30], [3, 31]]);
        return expect(selection4.isReversed()).toBeFalsy();
      });
    });
    describe(".selectWord()", function() {
      describe("when the cursor is inside a word", function() {
        return it("selects the entire word", function() {
          editor.setCursorScreenPosition([0, 8]);
          editor.selectWord();
          return expect(editor.getSelectedText()).toBe('quicksort');
        });
      });
      describe("when the cursor is between two words", function() {
        return it("selects the word the cursor is on", function() {
          editor.setCursorScreenPosition([0, 4]);
          editor.selectWord();
          expect(editor.getSelectedText()).toBe('quicksort');
          editor.setCursorScreenPosition([0, 3]);
          editor.selectWord();
          return expect(editor.getSelectedText()).toBe('var');
        });
      });
      describe("when the cursor is inside a region of whitespace", function() {
        return it("selects the whitespace region", function() {
          editor.setCursorScreenPosition([5, 2]);
          editor.selectWord();
          expect(editor.getSelectedBufferRange()).toEqual([[5, 0], [5, 6]]);
          editor.setCursorScreenPosition([5, 0]);
          editor.selectWord();
          return expect(editor.getSelectedBufferRange()).toEqual([[5, 0], [5, 6]]);
        });
      });
      return describe("when the cursor is at the end of the text", function() {
        return it("select the previous word", function() {
          editor.buffer.append('word');
          editor.moveCursorToBottom();
          editor.selectWord();
          return expect(editor.getSelectedBufferRange()).toEqual([[12, 2], [12, 6]]);
        });
      });
    });
    describe(".selectToFirstCharacterOfLine()", function() {
      return it("moves to the first character of the current line or the beginning of the line if it's already on the first character", function() {
        var cursor1, cursor2, selection1, selection2, _ref1, _ref2, _ref3;
        editor.setCursorScreenPosition([0, 5]);
        editor.addCursorAtScreenPosition([1, 7]);
        editor.selectToFirstCharacterOfLine();
        _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
        expect(cursor1.getBufferPosition()).toEqual([0, 0]);
        expect(cursor2.getBufferPosition()).toEqual([1, 2]);
        expect(editor.getSelections().length).toBe(2);
        _ref2 = editor.getSelections(), selection1 = _ref2[0], selection2 = _ref2[1];
        expect(selection1.getBufferRange()).toEqual([[0, 0], [0, 5]]);
        expect(selection1.isReversed()).toBeTruthy();
        expect(selection2.getBufferRange()).toEqual([[1, 2], [1, 7]]);
        expect(selection2.isReversed()).toBeTruthy();
        editor.selectToFirstCharacterOfLine();
        _ref3 = editor.getSelections(), selection1 = _ref3[0], selection2 = _ref3[1];
        expect(selection1.getBufferRange()).toEqual([[0, 0], [0, 5]]);
        expect(selection1.isReversed()).toBeTruthy();
        expect(selection2.getBufferRange()).toEqual([[1, 0], [1, 7]]);
        return expect(selection2.isReversed()).toBeTruthy();
      });
    });
    describe(".setSelectedBufferRanges(ranges)", function() {
      it("clears existing selections and creates selections for each of the given ranges", function() {
        editor.setSelectedBufferRanges([[[2, 2], [3, 3]], [[4, 4], [5, 5]]]);
        expect(editor.getSelectedBufferRanges()).toEqual([[[2, 2], [3, 3]], [[4, 4], [5, 5]]]);
        editor.setSelectedBufferRanges([[[5, 5], [6, 6]]]);
        return expect(editor.getSelectedBufferRanges()).toEqual([[[5, 5], [6, 6]]]);
      });
      it("merges intersecting selections", function() {
        editor.setSelectedBufferRanges([[[2, 2], [3, 3]], [[3, 0], [5, 5]]]);
        return expect(editor.getSelectedBufferRanges()).toEqual([[[2, 2], [5, 5]]]);
      });
      it("recyles existing selection instances", function() {
        var selection1, selection2, _ref1;
        selection = editor.getSelection();
        editor.setSelectedBufferRanges([[[2, 2], [3, 3]], [[4, 4], [5, 5]]]);
        _ref1 = editor.getSelections(), selection1 = _ref1[0], selection2 = _ref1[1];
        expect(selection1).toBe(selection);
        return expect(selection1.getBufferRange()).toEqual([[2, 2], [3, 3]]);
      });
      describe("when the 'preserveFolds' option is false (the default)", function() {
        return it("removes folds that contain the selections", function() {
          editor.setSelectedBufferRange([[0, 0], [0, 0]]);
          editor.createFold(1, 4);
          editor.createFold(2, 3);
          editor.createFold(6, 8);
          editor.createFold(10, 11);
          editor.setSelectedBufferRanges([[[2, 2], [3, 3]], [[6, 6], [7, 7]]]);
          expect(editor.lineForScreenRow(1).fold).toBeUndefined();
          expect(editor.lineForScreenRow(2).fold).toBeUndefined();
          expect(editor.lineForScreenRow(6).fold).toBeUndefined();
          return expect(editor.lineForScreenRow(10).fold).toBeDefined();
        });
      });
      return describe("when the 'preserveFolds' option is true", function() {
        return it("does not remove folds that contain the selections", function() {
          editor.setSelectedBufferRange([[0, 0], [0, 0]]);
          editor.createFold(1, 4);
          editor.createFold(6, 8);
          editor.setSelectedBufferRanges([[[2, 2], [3, 3]], [[6, 0], [6, 1]]], {
            preserveFolds: true
          });
          expect(editor.isFoldedAtBufferRow(1)).toBeTruthy();
          return expect(editor.isFoldedAtBufferRow(6)).toBeTruthy();
        });
      });
    });
    describe(".setSelectedBufferRange(range)", function() {
      return describe("when the 'autoscroll' option is true", function() {
        return it("autoscrolls to the selection", function() {
          editor.manageScrollPosition = true;
          editor.setLineHeightInPixels(10);
          editor.setDefaultCharWidth(10);
          editor.setHeight(50);
          editor.setWidth(50);
          editor.setHorizontalScrollbarHeight(0);
          expect(editor.getScrollTop()).toBe(0);
          editor.setSelectedBufferRange([[5, 6], [6, 8]], {
            autoscroll: true
          });
          expect(editor.getScrollBottom()).toBe((7 + editor.getVerticalScrollMargin()) * 10);
          expect(editor.getScrollRight()).toBe(50);
          editor.setSelectedBufferRange([[6, 6], [6, 8]], {
            autoscroll: true
          });
          expect(editor.getScrollBottom()).toBe((7 + editor.getVerticalScrollMargin()) * 10);
          return expect(editor.getScrollRight()).toBe((8 + editor.getHorizontalScrollMargin()) * 10);
        });
      });
    });
    describe(".selectMarker(marker)", function() {
      describe("if the marker is valid", function() {
        return it("selects the marker's range and returns the selected range", function() {
          var marker;
          marker = editor.markBufferRange([[0, 1], [3, 3]]);
          expect(editor.selectMarker(marker)).toEqual([[0, 1], [3, 3]]);
          return expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [3, 3]]);
        });
      });
      return describe("if the marker is invalid", function() {
        return it("does not change the selection and returns a falsy value", function() {
          var marker;
          marker = editor.markBufferRange([[0, 1], [3, 3]]);
          marker.destroy();
          expect(editor.selectMarker(marker)).toBeFalsy();
          return expect(editor.getSelectedBufferRange()).toEqual([[0, 0], [0, 0]]);
        });
      });
    });
    describe(".addSelectionForBufferRange(bufferRange)", function() {
      it("adds a selection for the specified buffer range", function() {
        editor.addSelectionForBufferRange([[3, 4], [5, 6]]);
        return expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [0, 0]], [[3, 4], [5, 6]]]);
      });
      return it("autoscrolls to the added selection if needed", function() {
        editor.manageScrollPosition = true;
        editor.setLineHeightInPixels(10);
        editor.setDefaultCharWidth(10);
        editor.setHeight(50);
        editor.setWidth(50);
        editor.addSelectionForBufferRange([[8, 10], [8, 15]]);
        expect(editor.getScrollTop()).toBe(75);
        return expect(editor.getScrollLeft()).toBe(160);
      });
    });
    describe(".addSelectionBelow()", function() {
      describe("when the selection is non-empty", function() {
        it("selects the same region of the line below current selections if possible", function() {
          var cursor, _i, _len, _ref1, _results;
          editor.setSelectedBufferRange([[3, 16], [3, 21]]);
          editor.addSelectionForBufferRange([[3, 25], [3, 34]]);
          editor.addSelectionBelow();
          expect(editor.getSelectedBufferRanges()).toEqual([[[3, 16], [3, 21]], [[3, 25], [3, 34]], [[4, 16], [4, 21]], [[4, 25], [4, 29]]]);
          _ref1 = editor.getCursors();
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            cursor = _ref1[_i];
            _results.push(expect(cursor.isVisible()).toBeFalsy());
          }
          return _results;
        });
        it("skips lines that are too short to create a non-empty selection", function() {
          editor.setSelectedBufferRange([[3, 31], [3, 38]]);
          editor.addSelectionBelow();
          return expect(editor.getSelectedBufferRanges()).toEqual([[[3, 31], [3, 38]], [[6, 31], [6, 38]]]);
        });
        it("honors the original selection's range (goal range) when adding across shorter lines", function() {
          editor.setSelectedBufferRange([[3, 22], [3, 38]]);
          editor.addSelectionBelow();
          editor.addSelectionBelow();
          editor.addSelectionBelow();
          return expect(editor.getSelectedBufferRanges()).toEqual([[[3, 22], [3, 38]], [[4, 22], [4, 29]], [[5, 22], [5, 30]], [[6, 22], [6, 38]]]);
        });
        return it("clears selection goal ranges when the selection changes", function() {
          editor.setSelectedBufferRange([[3, 22], [3, 38]]);
          editor.addSelectionBelow();
          editor.selectLeft();
          editor.addSelectionBelow();
          expect(editor.getSelectedBufferRanges()).toEqual([[[3, 22], [3, 37]], [[4, 22], [4, 29]], [[5, 22], [5, 28]]]);
          editor.addSelectionBelow();
          return expect(editor.getSelectedBufferRanges()).toEqual([[[3, 22], [3, 37]], [[4, 22], [4, 29]], [[5, 22], [5, 30]], [[6, 22], [6, 28]]]);
        });
      });
      return describe("when the selection is empty", function() {
        it("does not skip lines that are shorter than the current column", function() {
          editor.setCursorBufferPosition([3, 36]);
          editor.addSelectionBelow();
          editor.addSelectionBelow();
          editor.addSelectionBelow();
          return expect(editor.getSelectedBufferRanges()).toEqual([[[3, 36], [3, 36]], [[4, 29], [4, 29]], [[5, 30], [5, 30]], [[6, 36], [6, 36]]]);
        });
        it("skips empty lines when the column is non-zero", function() {
          editor.setCursorBufferPosition([9, 4]);
          editor.addSelectionBelow();
          return expect(editor.getSelectedBufferRanges()).toEqual([[[9, 4], [9, 4]], [[11, 4], [11, 4]]]);
        });
        return it("does not skip empty lines when the column is zero", function() {
          editor.setCursorBufferPosition([9, 0]);
          editor.addSelectionBelow();
          return expect(editor.getSelectedBufferRanges()).toEqual([[[9, 0], [9, 0]], [[10, 0], [10, 0]]]);
        });
      });
    });
    describe(".addSelectionAbove()", function() {
      describe("when the selection is non-empty", function() {
        it("selects the same region of the line above current selections if possible", function() {
          var cursor, _i, _len, _ref1, _results;
          editor.setSelectedBufferRange([[3, 16], [3, 21]]);
          editor.addSelectionForBufferRange([[3, 37], [3, 44]]);
          editor.addSelectionAbove();
          expect(editor.getSelectedBufferRanges()).toEqual([[[2, 16], [2, 21]], [[2, 37], [2, 40]], [[3, 16], [3, 21]], [[3, 37], [3, 44]]]);
          _ref1 = editor.getCursors();
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            cursor = _ref1[_i];
            _results.push(expect(cursor.isVisible()).toBeFalsy());
          }
          return _results;
        });
        it("skips lines that are too short to create a non-empty selection", function() {
          editor.setSelectedBufferRange([[6, 31], [6, 38]]);
          editor.addSelectionAbove();
          return expect(editor.getSelectedBufferRanges()).toEqual([[[3, 31], [3, 38]], [[6, 31], [6, 38]]]);
        });
        return it("honors the original selection's range (goal range) when adding across shorter lines", function() {
          editor.setSelectedBufferRange([[6, 22], [6, 38]]);
          editor.addSelectionAbove();
          editor.addSelectionAbove();
          editor.addSelectionAbove();
          return expect(editor.getSelectedBufferRanges()).toEqual([[[3, 22], [3, 38]], [[4, 22], [4, 29]], [[5, 22], [5, 30]], [[6, 22], [6, 38]]]);
        });
      });
      return describe("when the selection is empty", function() {
        it("does not skip lines that are shorter than the current column", function() {
          editor.setCursorBufferPosition([6, 36]);
          editor.addSelectionAbove();
          editor.addSelectionAbove();
          editor.addSelectionAbove();
          return expect(editor.getSelectedBufferRanges()).toEqual([[[3, 36], [3, 36]], [[4, 29], [4, 29]], [[5, 30], [5, 30]], [[6, 36], [6, 36]]]);
        });
        it("skips empty lines when the column is non-zero", function() {
          editor.setCursorBufferPosition([11, 4]);
          editor.addSelectionAbove();
          return expect(editor.getSelectedBufferRanges()).toEqual([[[9, 4], [9, 4]], [[11, 4], [11, 4]]]);
        });
        return it("does not skip empty lines when the column is zero", function() {
          editor.setCursorBufferPosition([10, 0]);
          editor.addSelectionAbove();
          return expect(editor.getSelectedBufferRanges()).toEqual([[[9, 0], [9, 0]], [[10, 0], [10, 0]]]);
        });
      });
    });
    describe(".splitSelectionsIntoLines()", function() {
      return it("splits all multi-line selections into one selection per line", function() {
        editor.setSelectedBufferRange([[0, 3], [2, 4]]);
        editor.splitSelectionsIntoLines();
        expect(editor.getSelectedBufferRanges()).toEqual([[[0, 3], [0, 29]], [[1, 0], [1, 30]], [[2, 0], [2, 4]]]);
        editor.setSelectedBufferRange([[0, 3], [1, 10]]);
        editor.splitSelectionsIntoLines();
        expect(editor.getSelectedBufferRanges()).toEqual([[[0, 3], [0, 29]], [[1, 0], [1, 10]]]);
        editor.setSelectedBufferRange([[0, 0], [0, 3]]);
        editor.splitSelectionsIntoLines();
        return expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [0, 3]]]);
      });
    });
    describe(".consolidateSelections()", function() {
      return it("destroys all selections but the most recent, returning true if any selections were destroyed", function() {
        var selection1, selection2, selection3;
        editor.setSelectedBufferRange([[3, 16], [3, 21]]);
        selection1 = editor.getSelection();
        selection2 = editor.addSelectionForBufferRange([[3, 25], [3, 34]]);
        selection3 = editor.addSelectionForBufferRange([[8, 4], [8, 10]]);
        expect(editor.getSelections()).toEqual([selection1, selection2, selection3]);
        expect(editor.consolidateSelections()).toBeTruthy();
        expect(editor.getSelections()).toEqual([selection3]);
        expect(selection3.isEmpty()).toBeFalsy();
        expect(editor.consolidateSelections()).toBeFalsy();
        return expect(editor.getSelections()).toEqual([selection3]);
      });
    });
    describe("when the cursor is moved while there is a selection", function() {
      var makeSelection;
      makeSelection = function() {
        return selection.setBufferRange([[1, 2], [1, 5]]);
      };
      return it("clears the selection", function() {
        makeSelection();
        editor.moveCursorDown();
        expect(selection.isEmpty()).toBeTruthy();
        makeSelection();
        editor.moveCursorUp();
        expect(selection.isEmpty()).toBeTruthy();
        makeSelection();
        editor.moveCursorLeft();
        expect(selection.isEmpty()).toBeTruthy();
        makeSelection();
        editor.moveCursorRight();
        expect(selection.isEmpty()).toBeTruthy();
        makeSelection();
        editor.setCursorScreenPosition([3, 3]);
        return expect(selection.isEmpty()).toBeTruthy();
      });
    });
    return it("does not share selections between different edit sessions for the same buffer", function() {
      var editor2;
      editor2 = null;
      waitsForPromise(function() {
        return atom.project.open('sample.js').then(function(o) {
          return editor2 = o;
        });
      });
      return runs(function() {
        editor.setSelectedBufferRanges([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]);
        editor2.setSelectedBufferRanges([[[8, 7], [6, 5]], [[4, 3], [2, 1]]]);
        return expect(editor2.getSelectedBufferRanges()).not.toEqual(editor.getSelectedBufferRanges());
      });
    });
  });
  describe("buffer manipulation", function() {
    describe(".insertText(text)", function() {
      describe("when there are multiple empty selections", function() {
        describe("when the cursors are on the same line", function() {
          return it("inserts the given text at the location of each cursor and moves the cursors to the end of each cursor's inserted text", function() {
            var cursor1, cursor2, _ref1;
            editor.setCursorScreenPosition([1, 2]);
            editor.addCursorAtScreenPosition([1, 5]);
            editor.insertText('xxx');
            expect(buffer.lineForRow(1)).toBe('  xxxvarxxx sort = function(items) {');
            _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
            expect(cursor1.getBufferPosition()).toEqual([1, 5]);
            return expect(cursor2.getBufferPosition()).toEqual([1, 11]);
          });
        });
        return describe("when the cursors are on different lines", function() {
          it("inserts the given text at the location of each cursor and moves the cursors to the end of each cursor's inserted text", function() {
            var cursor1, cursor2, _ref1;
            editor.setCursorScreenPosition([1, 2]);
            editor.addCursorAtScreenPosition([2, 4]);
            editor.insertText('xxx');
            expect(buffer.lineForRow(1)).toBe('  xxxvar sort = function(items) {');
            expect(buffer.lineForRow(2)).toBe('    xxxif (items.length <= 1) return items;');
            _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
            expect(cursor1.getBufferPosition()).toEqual([1, 5]);
            return expect(cursor2.getBufferPosition()).toEqual([2, 7]);
          });
          return it("autoscrolls to the last cursor", function() {
            editor.manageScrollPosition = true;
            editor.setCursorScreenPosition([1, 2]);
            editor.addCursorAtScreenPosition([10, 4]);
            editor.setLineHeightInPixels(10);
            editor.setHeight(50);
            expect(editor.getScrollTop()).toBe(0);
            editor.insertText('a');
            return expect(editor.getScrollTop()).toBe(80);
          });
        });
      });
      describe("when there are multiple non-empty selections", function() {
        describe("when the selections are on the same line", function() {
          return it("replaces each selection range with the inserted characters", function() {
            var cursor1, cursor2, selection1, selection2, _ref1, _ref2;
            editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[0, 22], [0, 24]]]);
            editor.insertText("x");
            _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
            _ref2 = editor.getSelections(), selection1 = _ref2[0], selection2 = _ref2[1];
            expect(cursor1.getScreenPosition()).toEqual([0, 5]);
            expect(cursor2.getScreenPosition()).toEqual([0, 15]);
            expect(selection1.isEmpty()).toBeTruthy();
            expect(selection2.isEmpty()).toBeTruthy();
            return expect(editor.lineForBufferRow(0)).toBe("var x = functix () {");
          });
        });
        return describe("when the selections are on different lines", function() {
          return it("replaces each selection with the given text, clears the selections, and places the cursor at the end of each selection's inserted text", function() {
            var selection1, selection2, _ref1;
            editor.setSelectedBufferRanges([[[1, 0], [1, 2]], [[2, 0], [2, 4]]]);
            editor.insertText('xxx');
            expect(buffer.lineForRow(1)).toBe('xxxvar sort = function(items) {');
            expect(buffer.lineForRow(2)).toBe('xxxif (items.length <= 1) return items;');
            _ref1 = editor.getSelections(), selection1 = _ref1[0], selection2 = _ref1[1];
            expect(selection1.isEmpty()).toBeTruthy();
            expect(selection1.cursor.getBufferPosition()).toEqual([1, 3]);
            expect(selection2.isEmpty()).toBeTruthy();
            return expect(selection2.cursor.getBufferPosition()).toEqual([2, 3]);
          });
        });
      });
      return describe("when there is a selection that ends on a folded line", function() {
        return it("destroys the selection", function() {
          editor.createFold(2, 4);
          editor.setSelectedBufferRange([[1, 0], [2, 0]]);
          editor.insertText('holy cow');
          return expect(editor.lineForScreenRow(2).fold).toBeUndefined();
        });
      });
    });
    describe(".insertNewline()", function() {
      describe("when there is a single cursor", function() {
        describe("when the cursor is at the beginning of a line", function() {
          return it("inserts an empty line before it", function() {
            editor.setCursorScreenPosition({
              row: 1,
              column: 0
            });
            editor.insertNewline();
            expect(buffer.lineForRow(1)).toBe('');
            return expect(editor.getCursorScreenPosition()).toEqual({
              row: 2,
              column: 0
            });
          });
        });
        describe("when the cursor is in the middle of a line", function() {
          return it("splits the current line to form a new line", function() {
            var lineBelowOriginalLine, originalLine;
            editor.setCursorScreenPosition({
              row: 1,
              column: 6
            });
            originalLine = buffer.lineForRow(1);
            lineBelowOriginalLine = buffer.lineForRow(2);
            editor.insertNewline();
            expect(buffer.lineForRow(1)).toBe(originalLine.slice(0, 6));
            expect(buffer.lineForRow(2)).toBe(originalLine.slice(6));
            expect(buffer.lineForRow(3)).toBe(lineBelowOriginalLine);
            return expect(editor.getCursorScreenPosition()).toEqual({
              row: 2,
              column: 0
            });
          });
        });
        return describe("when the cursor is on the end of a line", function() {
          return it("inserts an empty line after it", function() {
            editor.setCursorScreenPosition({
              row: 1,
              column: buffer.lineForRow(1).length
            });
            editor.insertNewline();
            expect(buffer.lineForRow(2)).toBe('');
            return expect(editor.getCursorScreenPosition()).toEqual({
              row: 2,
              column: 0
            });
          });
        });
      });
      return describe("when there are multiple cursors", function() {
        describe("when the cursors are on the same line", function() {
          return it("breaks the line at the cursor locations", function() {
            var cursor1, cursor2, _ref1;
            editor.setCursorScreenPosition([3, 13]);
            editor.addCursorAtScreenPosition([3, 38]);
            editor.insertNewline();
            expect(editor.lineForBufferRow(3)).toBe("    var pivot");
            expect(editor.lineForBufferRow(4)).toBe(" = items.shift(), current");
            expect(editor.lineForBufferRow(5)).toBe(", left = [], right = [];");
            expect(editor.lineForBufferRow(6)).toBe("    while(items.length > 0) {");
            _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
            expect(cursor1.getBufferPosition()).toEqual([4, 0]);
            return expect(cursor2.getBufferPosition()).toEqual([5, 0]);
          });
        });
        return describe("when the cursors are on different lines", function() {
          return it("inserts newlines at each cursor location", function() {
            var cursor1, cursor2, _ref1;
            editor.setCursorScreenPosition([3, 0]);
            editor.addCursorAtScreenPosition([6, 0]);
            editor.insertText("\n");
            expect(editor.lineForBufferRow(3)).toBe("");
            expect(editor.lineForBufferRow(4)).toBe("    var pivot = items.shift(), current, left = [], right = [];");
            expect(editor.lineForBufferRow(5)).toBe("    while(items.length > 0) {");
            expect(editor.lineForBufferRow(6)).toBe("      current = items.shift();");
            expect(editor.lineForBufferRow(7)).toBe("");
            expect(editor.lineForBufferRow(8)).toBe("      current < pivot ? left.push(current) : right.push(current);");
            expect(editor.lineForBufferRow(9)).toBe("    }");
            _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
            expect(cursor1.getBufferPosition()).toEqual([4, 0]);
            return expect(cursor2.getBufferPosition()).toEqual([8, 0]);
          });
        });
      });
    });
    describe(".insertNewlineBelow()", function() {
      describe("when the operation is undone", function() {
        return it("places the cursor back at the previous location", function() {
          editor.setCursorBufferPosition([0, 2]);
          editor.insertNewlineBelow();
          expect(editor.getCursorBufferPosition()).toEqual([1, 0]);
          editor.undo();
          return expect(editor.getCursorBufferPosition()).toEqual([0, 2]);
        });
      });
      return it("inserts a newline below the cursor's current line, autoindents it, and moves the cursor to the end of the line", function() {
        atom.config.set("editor.autoIndent", true);
        editor.insertNewlineBelow();
        expect(buffer.lineForRow(0)).toBe("var quicksort = function () {");
        expect(buffer.lineForRow(1)).toBe("  ");
        return expect(editor.getCursorBufferPosition()).toEqual([1, 2]);
      });
    });
    describe(".insertNewlineAbove()", function() {
      describe("when the cursor is on first line", function() {
        return it("inserts a newline on the first line and moves the cursor to the first line", function() {
          editor.setCursorBufferPosition([0]);
          editor.insertNewlineAbove();
          expect(editor.getCursorBufferPosition()).toEqual([0, 0]);
          expect(editor.lineForBufferRow(0)).toBe('');
          expect(editor.lineForBufferRow(1)).toBe('var quicksort = function () {');
          return expect(editor.buffer.getLineCount()).toBe(14);
        });
      });
      describe("when the cursor is not on the first line", function() {
        return it("inserts a newline above the current line and moves the cursor to the inserted line", function() {
          editor.setCursorBufferPosition([3, 4]);
          editor.insertNewlineAbove();
          expect(editor.getCursorBufferPosition()).toEqual([3, 0]);
          expect(editor.lineForBufferRow(3)).toBe('');
          expect(editor.lineForBufferRow(4)).toBe('    var pivot = items.shift(), current, left = [], right = [];');
          expect(editor.buffer.getLineCount()).toBe(14);
          editor.undo();
          return expect(editor.getCursorBufferPosition()).toEqual([3, 4]);
        });
      });
      return it("indents the new line to the correct level when editor.autoIndent is true", function() {
        atom.config.set('editor.autoIndent', true);
        editor.setText('  var test');
        editor.setCursorBufferPosition([0, 2]);
        editor.insertNewlineAbove();
        expect(editor.getCursorBufferPosition()).toEqual([0, 2]);
        expect(editor.lineForBufferRow(0)).toBe('  ');
        expect(editor.lineForBufferRow(1)).toBe('  var test');
        editor.setText('\n  var test');
        editor.setCursorBufferPosition([1, 2]);
        editor.insertNewlineAbove();
        expect(editor.getCursorBufferPosition()).toEqual([1, 2]);
        expect(editor.lineForBufferRow(0)).toBe('');
        expect(editor.lineForBufferRow(1)).toBe('  ');
        expect(editor.lineForBufferRow(2)).toBe('  var test');
        editor.setText('function() {\n}');
        editor.setCursorBufferPosition([1, 1]);
        editor.insertNewlineAbove();
        expect(editor.getCursorBufferPosition()).toEqual([1, 2]);
        expect(editor.lineForBufferRow(0)).toBe('function() {');
        expect(editor.lineForBufferRow(1)).toBe('  ');
        return expect(editor.lineForBufferRow(2)).toBe('}');
      });
    });
    describe("when a new line is appended before a closing tag (e.g. by pressing enter before a selection)", function() {
      return it("moves the line down and keeps the indentation level the same when editor.autoIndent is true", function() {
        atom.config.set('editor.autoIndent', true);
        editor.setCursorBufferPosition([9, 2]);
        editor.insertNewline();
        return expect(editor.lineForBufferRow(10)).toBe('  };');
      });
    });
    describe(".backspace()", function() {
      describe("when there is a single cursor", function() {
        var changeScreenRangeHandler;
        changeScreenRangeHandler = null;
        beforeEach(function() {
          var selection;
          selection = editor.getLastSelection();
          changeScreenRangeHandler = jasmine.createSpy('changeScreenRangeHandler');
          return selection.on('screen-range-changed', changeScreenRangeHandler);
        });
        describe("when the cursor is on the middle of the line", function() {
          return it("removes the character before the cursor", function() {
            var line;
            editor.setCursorScreenPosition({
              row: 1,
              column: 7
            });
            expect(buffer.lineForRow(1)).toBe("  var sort = function(items) {");
            editor.backspace();
            line = buffer.lineForRow(1);
            expect(line).toBe("  var ort = function(items) {");
            expect(editor.getCursorScreenPosition()).toEqual({
              row: 1,
              column: 6
            });
            expect(changeScreenRangeHandler).toHaveBeenCalled();
            return expect(editor.getCursor().isVisible()).toBeTruthy();
          });
        });
        describe("when the cursor is at the beginning of a line", function() {
          return it("joins it with the line above", function() {
            var line0, line1, originalLine0;
            originalLine0 = buffer.lineForRow(0);
            expect(originalLine0).toBe("var quicksort = function () {");
            expect(buffer.lineForRow(1)).toBe("  var sort = function(items) {");
            editor.setCursorScreenPosition({
              row: 1,
              column: 0
            });
            editor.backspace();
            line0 = buffer.lineForRow(0);
            line1 = buffer.lineForRow(1);
            expect(line0).toBe("var quicksort = function () {  var sort = function(items) {");
            expect(line1).toBe("    if (items.length <= 1) return items;");
            expect(editor.getCursorScreenPosition()).toEqual([0, originalLine0.length]);
            return expect(changeScreenRangeHandler).toHaveBeenCalled();
          });
        });
        describe("when the cursor is at the first column of the first line", function() {
          return it("does nothing, but doesn't raise an error", function() {
            editor.setCursorScreenPosition({
              row: 0,
              column: 0
            });
            return editor.backspace();
          });
        });
        describe("when the cursor is on the first column of a line below a fold", function() {
          return it("deletes the folded lines", function() {
            editor.setCursorScreenPosition([4, 0]);
            editor.foldCurrentRow();
            editor.setCursorScreenPosition([5, 0]);
            editor.backspace();
            expect(buffer.lineForRow(4)).toBe("    return sort(left).concat(pivot).concat(sort(right));");
            return expect(buffer.lineForRow(4).fold).toBeUndefined();
          });
        });
        describe("when the cursor is in the middle of a line below a fold", function() {
          return it("backspaces as normal", function() {
            editor.setCursorScreenPosition([4, 0]);
            editor.foldCurrentRow();
            editor.setCursorScreenPosition([5, 5]);
            editor.backspace();
            expect(buffer.lineForRow(7)).toBe("    }");
            return expect(buffer.lineForRow(8)).toBe("    eturn sort(left).concat(pivot).concat(sort(right));");
          });
        });
        return describe("when the cursor is on a folded screen line", function() {
          return it("deletes all of the folded lines along with the fold", function() {
            editor.setCursorBufferPosition([3, 0]);
            editor.foldCurrentRow();
            editor.backspace();
            expect(buffer.lineForRow(1)).toBe("");
            expect(buffer.lineForRow(2)).toBe("  return sort(Array.apply(this, arguments));");
            return expect(editor.getCursorScreenPosition()).toEqual([1, 0]);
          });
        });
      });
      describe("when there are multiple cursors", function() {
        describe("when cursors are on the same line", function() {
          return it("removes the characters preceding each cursor", function() {
            var cursor1, cursor2, selection1, selection2, _ref1, _ref2;
            editor.setCursorScreenPosition([3, 13]);
            editor.addCursorAtScreenPosition([3, 38]);
            editor.backspace();
            expect(editor.lineForBufferRow(3)).toBe("    var pivo = items.shift(), curren, left = [], right = [];");
            _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
            expect(cursor1.getBufferPosition()).toEqual([3, 12]);
            expect(cursor2.getBufferPosition()).toEqual([3, 36]);
            _ref2 = editor.getSelections(), selection1 = _ref2[0], selection2 = _ref2[1];
            expect(selection1.isEmpty()).toBeTruthy();
            return expect(selection2.isEmpty()).toBeTruthy();
          });
        });
        return describe("when cursors are on different lines", function() {
          describe("when the cursors are in the middle of their lines", function() {
            return it("removes the characters preceding each cursor", function() {
              var cursor1, cursor2, selection1, selection2, _ref1, _ref2;
              editor.setCursorScreenPosition([3, 13]);
              editor.addCursorAtScreenPosition([4, 10]);
              editor.backspace();
              expect(editor.lineForBufferRow(3)).toBe("    var pivo = items.shift(), current, left = [], right = [];");
              expect(editor.lineForBufferRow(4)).toBe("    whileitems.length > 0) {");
              _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
              expect(cursor1.getBufferPosition()).toEqual([3, 12]);
              expect(cursor2.getBufferPosition()).toEqual([4, 9]);
              _ref2 = editor.getSelections(), selection1 = _ref2[0], selection2 = _ref2[1];
              expect(selection1.isEmpty()).toBeTruthy();
              return expect(selection2.isEmpty()).toBeTruthy();
            });
          });
          return describe("when the cursors are on the first column of their lines", function() {
            return it("removes the newlines preceding each cursor", function() {
              var cursor1, cursor2, _ref1;
              editor.setCursorScreenPosition([3, 0]);
              editor.addCursorAtScreenPosition([6, 0]);
              editor.backspace();
              expect(editor.lineForBufferRow(2)).toBe("    if (items.length <= 1) return items;    var pivot = items.shift(), current, left = [], right = [];");
              expect(editor.lineForBufferRow(3)).toBe("    while(items.length > 0) {");
              expect(editor.lineForBufferRow(4)).toBe("      current = items.shift();      current < pivot ? left.push(current) : right.push(current);");
              expect(editor.lineForBufferRow(5)).toBe("    }");
              _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
              expect(cursor1.getBufferPosition()).toEqual([2, 40]);
              return expect(cursor2.getBufferPosition()).toEqual([4, 30]);
            });
          });
        });
      });
      describe("when there is a single selection", function() {
        it("deletes the selection, but not the character before it", function() {
          editor.setSelectedBufferRange([[0, 5], [0, 9]]);
          editor.backspace();
          return expect(editor.buffer.lineForRow(0)).toBe('var qsort = function () {');
        });
        return describe("when the selection ends on a folded line", function() {
          return it("preserves the fold", function() {
            editor.setSelectedBufferRange([[3, 0], [4, 0]]);
            editor.foldBufferRow(4);
            editor.backspace();
            expect(buffer.lineForRow(3)).toBe("    while(items.length > 0) {");
            return expect(editor.lineForScreenRow(3).fold).toBeDefined();
          });
        });
      });
      return describe("when there are multiple selections", function() {
        return it("removes all selected text", function() {
          editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[0, 16], [0, 24]]]);
          editor.backspace();
          return expect(editor.lineForBufferRow(0)).toBe('var  =  () {');
        });
      });
    });
    describe(".deleteToBeginningOfWord()", function() {
      describe("when no text is selected", function() {
        return it("deletes all text between the cursor and the beginning of the word", function() {
          var cursor1, cursor2, _ref1;
          editor.setCursorBufferPosition([1, 24]);
          editor.addCursorAtBufferPosition([3, 5]);
          _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
          editor.deleteToBeginningOfWord();
          expect(buffer.lineForRow(1)).toBe('  var sort = function(ems) {');
          expect(buffer.lineForRow(3)).toBe('    ar pivot = items.shift(), current, left = [], right = [];');
          expect(cursor1.getBufferPosition()).toEqual([1, 22]);
          expect(cursor2.getBufferPosition()).toEqual([3, 4]);
          editor.deleteToBeginningOfWord();
          expect(buffer.lineForRow(1)).toBe('  var sort = functionems) {');
          expect(buffer.lineForRow(2)).toBe('    if (items.length <= 1) return itemsar pivot = items.shift(), current, left = [], right = [];');
          expect(cursor1.getBufferPosition()).toEqual([1, 21]);
          expect(cursor2.getBufferPosition()).toEqual([2, 39]);
          editor.deleteToBeginningOfWord();
          expect(buffer.lineForRow(1)).toBe('  var sort = ems) {');
          expect(buffer.lineForRow(2)).toBe('    if (items.length <= 1) return ar pivot = items.shift(), current, left = [], right = [];');
          expect(cursor1.getBufferPosition()).toEqual([1, 13]);
          expect(cursor2.getBufferPosition()).toEqual([2, 34]);
          editor.setText('  var sort');
          editor.setCursorBufferPosition([0, 2]);
          editor.deleteToBeginningOfWord();
          return expect(buffer.lineForRow(0)).toBe('var sort');
        });
      });
      return describe("when text is selected", function() {
        return it("deletes only selected text", function() {
          editor.setSelectedBufferRanges([[[1, 24], [1, 27]], [[2, 0], [2, 4]]]);
          editor.deleteToBeginningOfWord();
          expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');
          return expect(buffer.lineForRow(2)).toBe('if (items.length <= 1) return items;');
        });
      });
    });
    describe('.deleteToEndOfLine()', function() {
      describe('when no text is selected', function() {
        it('deletes all text between the cursor and the end of the line', function() {
          var cursor1, cursor2, _ref1;
          editor.setCursorBufferPosition([1, 24]);
          editor.addCursorAtBufferPosition([2, 5]);
          _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
          editor.deleteToEndOfLine();
          expect(buffer.lineForRow(1)).toBe('  var sort = function(it');
          expect(buffer.lineForRow(2)).toBe('    i');
          expect(cursor1.getBufferPosition()).toEqual([1, 24]);
          return expect(cursor2.getBufferPosition()).toEqual([2, 5]);
        });
        return describe('when at the end of the line', function() {
          return it('deletes the next newline', function() {
            editor.setCursorBufferPosition([1, 30]);
            editor.deleteToEndOfLine();
            return expect(buffer.lineForRow(1)).toBe('  var sort = function(items) {    if (items.length <= 1) return items;');
          });
        });
      });
      return describe('when text is selected', function() {
        return it('deletes only the text in the selection', function() {
          editor.setSelectedBufferRanges([[[1, 24], [1, 27]], [[2, 0], [2, 4]]]);
          editor.deleteToEndOfLine();
          expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');
          return expect(buffer.lineForRow(2)).toBe('if (items.length <= 1) return items;');
        });
      });
    });
    describe(".deleteToBeginningOfLine()", function() {
      describe("when no text is selected", function() {
        it("deletes all text between the cursor and the beginning of the line", function() {
          var cursor1, cursor2, _ref1;
          editor.setCursorBufferPosition([1, 24]);
          editor.addCursorAtBufferPosition([2, 5]);
          _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
          editor.deleteToBeginningOfLine();
          expect(buffer.lineForRow(1)).toBe('ems) {');
          expect(buffer.lineForRow(2)).toBe('f (items.length <= 1) return items;');
          expect(cursor1.getBufferPosition()).toEqual([1, 0]);
          return expect(cursor2.getBufferPosition()).toEqual([2, 0]);
        });
        return describe("when at the beginning of the line", function() {
          return it("deletes the newline", function() {
            editor.setCursorBufferPosition([2]);
            editor.deleteToBeginningOfLine();
            return expect(buffer.lineForRow(1)).toBe('  var sort = function(items) {    if (items.length <= 1) return items;');
          });
        });
      });
      return describe("when text is selected", function() {
        return it("still deletes all text to begginning of the line", function() {
          editor.setSelectedBufferRanges([[[1, 24], [1, 27]], [[2, 0], [2, 4]]]);
          editor.deleteToBeginningOfLine();
          expect(buffer.lineForRow(1)).toBe('ems) {');
          return expect(buffer.lineForRow(2)).toBe('    if (items.length <= 1) return items;');
        });
      });
    });
    describe(".delete()", function() {
      describe("when there is a single cursor", function() {
        describe("when the cursor is on the middle of a line", function() {
          return it("deletes the character following the cursor", function() {
            editor.setCursorScreenPosition([1, 6]);
            editor["delete"]();
            return expect(buffer.lineForRow(1)).toBe('  var ort = function(items) {');
          });
        });
        describe("when the cursor is on the end of a line", function() {
          return it("joins the line with the following line", function() {
            editor.setCursorScreenPosition([1, buffer.lineForRow(1).length]);
            editor["delete"]();
            return expect(buffer.lineForRow(1)).toBe('  var sort = function(items) {    if (items.length <= 1) return items;');
          });
        });
        describe("when the cursor is on the last column of the last line", function() {
          return it("does nothing, but doesn't raise an error", function() {
            editor.setCursorScreenPosition([12, buffer.lineForRow(12).length]);
            editor["delete"]();
            return expect(buffer.lineForRow(12)).toBe('};');
          });
        });
        describe("when the cursor is on the end of a line above a fold", function() {
          return it("only deletes the lines inside the fold", function() {
            var cursorPositionBefore;
            editor.foldBufferRow(4);
            editor.setCursorScreenPosition([3, Infinity]);
            cursorPositionBefore = editor.getCursorScreenPosition();
            editor["delete"]();
            expect(buffer.lineForRow(3)).toBe("    var pivot = items.shift(), current, left = [], right = [];");
            expect(buffer.lineForRow(4)).toBe("    return sort(left).concat(pivot).concat(sort(right));");
            return expect(editor.getCursorScreenPosition()).toEqual(cursorPositionBefore);
          });
        });
        describe("when the cursor is in the middle a line above a fold", function() {
          return it("deletes as normal", function() {
            var cursorPositionBefore;
            editor.foldBufferRow(4);
            editor.setCursorScreenPosition([3, 4]);
            cursorPositionBefore = editor.getCursorScreenPosition();
            editor["delete"]();
            expect(buffer.lineForRow(3)).toBe("    ar pivot = items.shift(), current, left = [], right = [];");
            expect(editor.lineForScreenRow(4).fold).toBeDefined();
            return expect(editor.getCursorScreenPosition()).toEqual([3, 4]);
          });
        });
        return describe("when the cursor is on a folded line", function() {
          return it("removes the lines contained by the fold", function() {
            var oldLine7, oldLine8;
            editor.setSelectedBufferRange([[2, 0], [2, 0]]);
            editor.createFold(2, 4);
            editor.createFold(2, 6);
            oldLine7 = buffer.lineForRow(7);
            oldLine8 = buffer.lineForRow(8);
            editor["delete"]();
            expect(editor.lineForScreenRow(2).text).toBe(oldLine7);
            return expect(editor.lineForScreenRow(3).text).toBe(oldLine8);
          });
        });
      });
      describe("when there are multiple cursors", function() {
        describe("when cursors are on the same line", function() {
          return it("removes the characters following each cursor", function() {
            var cursor1, cursor2, selection1, selection2, _ref1, _ref2;
            editor.setCursorScreenPosition([3, 13]);
            editor.addCursorAtScreenPosition([3, 38]);
            editor["delete"]();
            expect(editor.lineForBufferRow(3)).toBe("    var pivot= items.shift(), current left = [], right = [];");
            _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
            expect(cursor1.getBufferPosition()).toEqual([3, 13]);
            expect(cursor2.getBufferPosition()).toEqual([3, 37]);
            _ref2 = editor.getSelections(), selection1 = _ref2[0], selection2 = _ref2[1];
            expect(selection1.isEmpty()).toBeTruthy();
            return expect(selection2.isEmpty()).toBeTruthy();
          });
        });
        return describe("when cursors are on different lines", function() {
          describe("when the cursors are in the middle of the lines", function() {
            return it("removes the characters following each cursor", function() {
              var cursor1, cursor2, selection1, selection2, _ref1, _ref2;
              editor.setCursorScreenPosition([3, 13]);
              editor.addCursorAtScreenPosition([4, 10]);
              editor["delete"]();
              expect(editor.lineForBufferRow(3)).toBe("    var pivot= items.shift(), current, left = [], right = [];");
              expect(editor.lineForBufferRow(4)).toBe("    while(tems.length > 0) {");
              _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
              expect(cursor1.getBufferPosition()).toEqual([3, 13]);
              expect(cursor2.getBufferPosition()).toEqual([4, 10]);
              _ref2 = editor.getSelections(), selection1 = _ref2[0], selection2 = _ref2[1];
              expect(selection1.isEmpty()).toBeTruthy();
              return expect(selection2.isEmpty()).toBeTruthy();
            });
          });
          return describe("when the cursors are at the end of their lines", function() {
            return it("removes the newlines following each cursor", function() {
              var cursor1, cursor2, _ref1;
              editor.setCursorScreenPosition([0, 29]);
              editor.addCursorAtScreenPosition([1, 30]);
              editor["delete"]();
              expect(editor.lineForBufferRow(0)).toBe("var quicksort = function () {  var sort = function(items) {    if (items.length <= 1) return items;");
              _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
              expect(cursor1.getBufferPosition()).toEqual([0, 29]);
              return expect(cursor2.getBufferPosition()).toEqual([0, 59]);
            });
          });
        });
      });
      describe("when there is a single selection", function() {
        return it("deletes the selection, but not the character following it", function() {
          editor.setSelectedBufferRanges([[[1, 24], [1, 27]], [[2, 0], [2, 4]]]);
          editor["delete"]();
          expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');
          expect(buffer.lineForRow(2)).toBe('if (items.length <= 1) return items;');
          return expect(editor.getSelection().isEmpty()).toBeTruthy();
        });
      });
      return describe("when there are multiple selections", function() {
        return describe("when selections are on the same line", function() {
          return it("removes all selected text", function() {
            editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[0, 16], [0, 24]]]);
            editor["delete"]();
            return expect(editor.lineForBufferRow(0)).toBe('var  =  () {');
          });
        });
      });
    });
    describe(".deleteToEndOfWord()", function() {
      describe("when no text is selected", function() {
        return it("deletes to the end of the word", function() {
          var cursor1, cursor2, _ref1;
          editor.setCursorBufferPosition([1, 24]);
          editor.addCursorAtBufferPosition([2, 5]);
          _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1];
          editor.deleteToEndOfWord();
          expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');
          expect(buffer.lineForRow(2)).toBe('    i (items.length <= 1) return items;');
          expect(cursor1.getBufferPosition()).toEqual([1, 24]);
          expect(cursor2.getBufferPosition()).toEqual([2, 5]);
          editor.deleteToEndOfWord();
          expect(buffer.lineForRow(1)).toBe('  var sort = function(it {');
          expect(buffer.lineForRow(2)).toBe('    iitems.length <= 1) return items;');
          expect(cursor1.getBufferPosition()).toEqual([1, 24]);
          return expect(cursor2.getBufferPosition()).toEqual([2, 5]);
        });
      });
      return describe("when text is selected", function() {
        return it("deletes only selected text", function() {
          editor.setSelectedBufferRange([[1, 24], [1, 27]]);
          editor.deleteToEndOfWord();
          return expect(buffer.lineForRow(1)).toBe('  var sort = function(it) {');
        });
      });
    });
    describe(".indent()", function() {
      describe("when the selection is empty", function() {
        describe("when autoIndent is disabled", function() {
          describe("if 'softTabs' is true (the default)", function() {
            it("inserts 'tabLength' spaces into the buffer", function() {
              var tabRegex;
              tabRegex = new RegExp("^[ ]{" + (editor.getTabLength()) + "}");
              expect(buffer.lineForRow(0)).not.toMatch(tabRegex);
              editor.indent();
              return expect(buffer.lineForRow(0)).toMatch(tabRegex);
            });
            return it("respects the tab stops when cursor is in the middle of a tab", function() {
              editor.setTabLength(4);
              buffer.insert([12, 2], "\n ");
              editor.setCursorBufferPosition([13, 1]);
              editor.indent();
              expect(buffer.lineForRow(13)).toMatch(/^\s+$/);
              expect(buffer.lineForRow(13).length).toBe(4);
              expect(editor.getCursorBufferPosition()).toEqual([13, 4]);
              buffer.insert([13, 0], "  ");
              editor.setCursorBufferPosition([13, 6]);
              editor.indent();
              return expect(buffer.lineForRow(13).length).toBe(8);
            });
          });
          return describe("if 'softTabs' is false", function() {
            return it("insert a \t into the buffer", function() {
              editor.setSoftTabs(false);
              expect(buffer.lineForRow(0)).not.toMatch(/^\t/);
              editor.indent();
              return expect(buffer.lineForRow(0)).toMatch(/^\t/);
            });
          });
        });
        return describe("when autoIndent is enabled", function() {
          describe("when the cursor's column is less than the suggested level of indentation", function() {
            describe("when 'softTabs' is true (the default)", function() {
              it("moves the cursor to the end of the leading whitespace and inserts enough whitespace to bring the line to the suggested level of indentaion", function() {
                buffer.insert([5, 0], "  \n");
                editor.setCursorBufferPosition([5, 0]);
                editor.indent({
                  autoIndent: true
                });
                expect(buffer.lineForRow(5)).toMatch(/^\s+$/);
                expect(buffer.lineForRow(5).length).toBe(6);
                return expect(editor.getCursorBufferPosition()).toEqual([5, 6]);
              });
              return it("respects the tab stops when cursor is in the middle of a tab", function() {
                editor.setTabLength(4);
                buffer.insert([12, 2], "\n ");
                editor.setCursorBufferPosition([13, 1]);
                editor.indent({
                  autoIndent: true
                });
                expect(buffer.lineForRow(13)).toMatch(/^\s+$/);
                expect(buffer.lineForRow(13).length).toBe(4);
                expect(editor.getCursorBufferPosition()).toEqual([13, 4]);
                buffer.insert([13, 0], "  ");
                editor.setCursorBufferPosition([13, 6]);
                editor.indent({
                  autoIndent: true
                });
                return expect(buffer.lineForRow(13).length).toBe(8);
              });
            });
            return describe("when 'softTabs' is false", function() {
              return it("moves the cursor to the end of the leading whitespace and inserts enough tabs to bring the line to the suggested level of indentaion", function() {
                convertToHardTabs(buffer);
                editor.setSoftTabs(false);
                buffer.insert([5, 0], "\t\n");
                editor.setCursorBufferPosition([5, 0]);
                editor.indent({
                  autoIndent: true
                });
                expect(buffer.lineForRow(5)).toMatch(/^\t\t\t$/);
                return expect(editor.getCursorBufferPosition()).toEqual([5, 3]);
              });
            });
          });
          return describe("when the line's indent level is greater than the suggested level of indentation", function() {
            describe("when 'softTabs' is true (the default)", function() {
              return it("moves the cursor to the end of the leading whitespace and inserts 'tabLength' spaces into the buffer", function() {
                buffer.insert([7, 0], "      \n");
                editor.setCursorBufferPosition([7, 2]);
                editor.indent({
                  autoIndent: true
                });
                expect(buffer.lineForRow(7)).toMatch(/^\s+$/);
                expect(buffer.lineForRow(7).length).toBe(8);
                return expect(editor.getCursorBufferPosition()).toEqual([7, 8]);
              });
            });
            return describe("when 'softTabs' is false", function() {
              return it("moves the cursor to the end of the leading whitespace and inserts \t into the buffer", function() {
                convertToHardTabs(buffer);
                editor.setSoftTabs(false);
                buffer.insert([7, 0], "\t\t\t\n");
                editor.setCursorBufferPosition([7, 1]);
                editor.indent({
                  autoIndent: true
                });
                expect(buffer.lineForRow(7)).toMatch(/^\t\t\t\t$/);
                return expect(editor.getCursorBufferPosition()).toEqual([7, 4]);
              });
            });
          });
        });
      });
      describe("when the selection is not empty", function() {
        return it("indents the selected lines", function() {
          var selection;
          editor.setSelectedBufferRange([[0, 0], [10, 0]]);
          selection = editor.getSelection();
          spyOn(selection, "indentSelectedRows");
          editor.indent();
          return expect(selection.indentSelectedRows).toHaveBeenCalled();
        });
      });
      return describe("if editor.softTabs is false", function() {
        return it("inserts a tab character into the buffer", function() {
          editor.setSoftTabs(false);
          expect(buffer.lineForRow(0)).not.toMatch(/^\t/);
          editor.indent();
          expect(buffer.lineForRow(0)).toMatch(/^\t/);
          expect(editor.getCursorBufferPosition()).toEqual([0, 1]);
          expect(editor.getCursorScreenPosition()).toEqual([0, editor.getTabLength()]);
          editor.indent();
          expect(buffer.lineForRow(0)).toMatch(/^\t\t/);
          expect(editor.getCursorBufferPosition()).toEqual([0, 2]);
          return expect(editor.getCursorScreenPosition()).toEqual([0, editor.getTabLength() * 2]);
        });
      });
    });
    describe("clipboard operations", function() {
      beforeEach(function() {
        return editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[1, 6], [1, 10]]]);
      });
      describe(".cutSelectedText()", function() {
        return it("removes the selected text from the buffer and places it on the clipboard", function() {
          editor.cutSelectedText();
          expect(buffer.lineForRow(0)).toBe("var  = function () {");
          expect(buffer.lineForRow(1)).toBe("  var  = function(items) {");
          return expect(clipboard.readText()).toBe('quicksort\nsort');
        });
      });
      describe(".cutToEndOfLine()", function() {
        describe("when soft wrap is on", function() {
          return it("cuts up to the end of the line", function() {
            editor.setSoftWrap(true);
            editor.setEditorWidthInChars(10);
            editor.setCursorScreenPosition([2, 2]);
            editor.cutToEndOfLine();
            return expect(editor.lineForScreenRow(2).text).toBe('=  () {');
          });
        });
        return describe("when soft wrap is off", function() {
          describe("when nothing is selected", function() {
            return it("cuts up to the end of the line", function() {
              editor.setCursorBufferPosition([2, 20]);
              editor.addCursorAtBufferPosition([3, 20]);
              editor.cutToEndOfLine();
              expect(buffer.lineForRow(2)).toBe('    if (items.length');
              expect(buffer.lineForRow(3)).toBe('    var pivot = item');
              return expect(atom.clipboard.read()).toBe(' <= 1) return items;\ns.shift(), current, left = [], right = [];');
            });
          });
          return describe("when text is selected", function() {
            return it("only cuts the selected text, not to the end of the line", function() {
              editor.setSelectedBufferRanges([[[2, 20], [2, 30]], [[3, 20], [3, 20]]]);
              editor.cutToEndOfLine();
              expect(buffer.lineForRow(2)).toBe('    if (items.lengthurn items;');
              expect(buffer.lineForRow(3)).toBe('    var pivot = item');
              return expect(atom.clipboard.read()).toBe(' <= 1) ret\ns.shift(), current, left = [], right = [];');
            });
          });
        });
      });
      describe(".copySelectedText()", function() {
        return it("copies selected text onto the clipboard", function() {
          editor.setSelectedBufferRanges([[[0, 4], [0, 13]], [[1, 6], [1, 10]], [[2, 8], [2, 13]]]);
          editor.copySelectedText();
          expect(buffer.lineForRow(0)).toBe("var quicksort = function () {");
          expect(buffer.lineForRow(1)).toBe("  var sort = function(items) {");
          expect(buffer.lineForRow(2)).toBe("    if (items.length <= 1) return items;");
          expect(clipboard.readText()).toBe('quicksort\nsort\nitems');
          return expect(atom.clipboard.readWithMetadata().metadata.selections).toEqual(['quicksort', 'sort', 'items']);
        });
      });
      return describe(".pasteText()", function() {
        it("pastes text into the buffer", function() {
          atom.clipboard.write('first');
          editor.pasteText();
          expect(editor.lineForBufferRow(0)).toBe("var first = function () {");
          return expect(editor.lineForBufferRow(1)).toBe("  var first = function(items) {");
        });
        return describe('when the clipboard has many selections', function() {
          it("pastes each selection separately into the buffer", function() {
            atom.clipboard.write('first\nsecond', {
              selections: ['first', 'second']
            });
            editor.pasteText();
            expect(editor.lineForBufferRow(0)).toBe("var first = function () {");
            return expect(editor.lineForBufferRow(1)).toBe("  var second = function(items) {");
          });
          return describe('and the selections count does not match', function() {
            return it("pastes the whole text into the buffer", function() {
              atom.clipboard.write('first\nsecond\nthird', {
                selections: ['first', 'second', 'third']
              });
              editor.pasteText();
              expect(editor.lineForBufferRow(0)).toBe("var first");
              expect(editor.lineForBufferRow(1)).toBe("second");
              expect(editor.lineForBufferRow(2)).toBe("third = function () {");
              expect(editor.lineForBufferRow(3)).toBe("  var first");
              expect(editor.lineForBufferRow(4)).toBe("second");
              return expect(editor.lineForBufferRow(5)).toBe("third = function(items) {");
            });
          });
        });
      });
    });
    describe(".indentSelectedRows()", function() {
      describe("when nothing is selected", function() {
        describe("when softTabs is enabled", function() {
          return it("indents line and retains selection", function() {
            editor.setSelectedBufferRange([[0, 3], [0, 3]]);
            editor.indentSelectedRows();
            expect(buffer.lineForRow(0)).toBe("  var quicksort = function () {");
            return expect(editor.getSelectedBufferRange()).toEqual([[0, 3 + editor.getTabLength()], [0, 3 + editor.getTabLength()]]);
          });
        });
        return describe("when softTabs is disabled", function() {
          return it("indents line and retains selection", function() {
            convertToHardTabs(buffer);
            editor.setSoftTabs(false);
            editor.setSelectedBufferRange([[0, 3], [0, 3]]);
            editor.indentSelectedRows();
            expect(buffer.lineForRow(0)).toBe("\tvar quicksort = function () {");
            return expect(editor.getSelectedBufferRange()).toEqual([[0, 3 + 1], [0, 3 + 1]]);
          });
        });
      });
      describe("when one line is selected", function() {
        describe("when softTabs is enabled", function() {
          return it("indents line and retains selection", function() {
            editor.setSelectedBufferRange([[0, 4], [0, 14]]);
            editor.indentSelectedRows();
            expect(buffer.lineForRow(0)).toBe("" + (editor.getTabText()) + "var quicksort = function () {");
            return expect(editor.getSelectedBufferRange()).toEqual([[0, 4 + editor.getTabLength()], [0, 14 + editor.getTabLength()]]);
          });
        });
        return describe("when softTabs is disabled", function() {
          return it("indents line and retains selection", function() {
            convertToHardTabs(buffer);
            editor.setSoftTabs(false);
            editor.setSelectedBufferRange([[0, 4], [0, 14]]);
            editor.indentSelectedRows();
            expect(buffer.lineForRow(0)).toBe("\tvar quicksort = function () {");
            return expect(editor.getSelectedBufferRange()).toEqual([[0, 4 + 1], [0, 14 + 1]]);
          });
        });
      });
      return describe("when multiple lines are selected", function() {
        describe("when softTabs is enabled", function() {
          it("indents selected lines (that are not empty) and retains selection", function() {
            editor.setSelectedBufferRange([[9, 1], [11, 15]]);
            editor.indentSelectedRows();
            expect(buffer.lineForRow(9)).toBe("    };");
            expect(buffer.lineForRow(10)).toBe("");
            expect(buffer.lineForRow(11)).toBe("    return sort(Array.apply(this, arguments));");
            return expect(editor.getSelectedBufferRange()).toEqual([[9, 1 + editor.getTabLength()], [11, 15 + editor.getTabLength()]]);
          });
          return it("does not indent the last row if the selection ends at column 0", function() {
            editor.setSelectedBufferRange([[9, 1], [11, 0]]);
            editor.indentSelectedRows();
            expect(buffer.lineForRow(9)).toBe("    };");
            expect(buffer.lineForRow(10)).toBe("");
            expect(buffer.lineForRow(11)).toBe("  return sort(Array.apply(this, arguments));");
            return expect(editor.getSelectedBufferRange()).toEqual([[9, 1 + editor.getTabLength()], [11, 0]]);
          });
        });
        return describe("when softTabs is disabled", function() {
          return it("indents selected lines (that are not empty) and retains selection", function() {
            convertToHardTabs(buffer);
            editor.setSoftTabs(false);
            editor.setSelectedBufferRange([[9, 1], [11, 15]]);
            editor.indentSelectedRows();
            expect(buffer.lineForRow(9)).toBe("\t\t};");
            expect(buffer.lineForRow(10)).toBe("");
            expect(buffer.lineForRow(11)).toBe("\t\treturn sort(Array.apply(this, arguments));");
            return expect(editor.getSelectedBufferRange()).toEqual([[9, 1 + 1], [11, 15 + 1]]);
          });
        });
      });
    });
    describe(".outdentSelectedRows()", function() {
      describe("when nothing is selected", function() {
        it("outdents line and retains selection", function() {
          editor.setSelectedBufferRange([[1, 3], [1, 3]]);
          editor.outdentSelectedRows();
          expect(buffer.lineForRow(1)).toBe("var sort = function(items) {");
          return expect(editor.getSelectedBufferRange()).toEqual([[1, 3 - editor.getTabLength()], [1, 3 - editor.getTabLength()]]);
        });
        it("outdents when indent is less than a tab length", function() {
          editor.insertText(' ');
          editor.outdentSelectedRows();
          return expect(buffer.lineForRow(0)).toBe("var quicksort = function () {");
        });
        it("outdents a single hard tab when indent is multiple hard tabs and and the session is using soft tabs", function() {
          editor.insertText('\t\t');
          editor.outdentSelectedRows();
          expect(buffer.lineForRow(0)).toBe("\tvar quicksort = function () {");
          editor.outdentSelectedRows();
          return expect(buffer.lineForRow(0)).toBe("var quicksort = function () {");
        });
        it("outdents when a mix of hard tabs and soft tabs are used", function() {
          editor.insertText('\t   ');
          editor.outdentSelectedRows();
          expect(buffer.lineForRow(0)).toBe("   var quicksort = function () {");
          editor.outdentSelectedRows();
          expect(buffer.lineForRow(0)).toBe(" var quicksort = function () {");
          editor.outdentSelectedRows();
          return expect(buffer.lineForRow(0)).toBe("var quicksort = function () {");
        });
        return it("outdents only up to the first non-space non-tab character", function() {
          editor.insertText(' \tfoo\t ');
          editor.outdentSelectedRows();
          expect(buffer.lineForRow(0)).toBe("\tfoo\t var quicksort = function () {");
          editor.outdentSelectedRows();
          expect(buffer.lineForRow(0)).toBe("foo\t var quicksort = function () {");
          editor.outdentSelectedRows();
          return expect(buffer.lineForRow(0)).toBe("foo\t var quicksort = function () {");
        });
      });
      describe("when one line is selected", function() {
        return it("outdents line and retains editor", function() {
          editor.setSelectedBufferRange([[1, 4], [1, 14]]);
          editor.outdentSelectedRows();
          expect(buffer.lineForRow(1)).toBe("var sort = function(items) {");
          return expect(editor.getSelectedBufferRange()).toEqual([[1, 4 - editor.getTabLength()], [1, 14 - editor.getTabLength()]]);
        });
      });
      return describe("when multiple lines are selected", function() {
        it("outdents selected lines and retains editor", function() {
          editor.setSelectedBufferRange([[0, 1], [3, 15]]);
          editor.outdentSelectedRows();
          expect(buffer.lineForRow(0)).toBe("var quicksort = function () {");
          expect(buffer.lineForRow(1)).toBe("var sort = function(items) {");
          expect(buffer.lineForRow(2)).toBe("  if (items.length <= 1) return items;");
          expect(buffer.lineForRow(3)).toBe("  var pivot = items.shift(), current, left = [], right = [];");
          return expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [3, 15 - editor.getTabLength()]]);
        });
        return it("does not outdent the last line of the selection if it ends at column 0", function() {
          editor.setSelectedBufferRange([[0, 1], [3, 0]]);
          editor.outdentSelectedRows();
          expect(buffer.lineForRow(0)).toBe("var quicksort = function () {");
          expect(buffer.lineForRow(1)).toBe("var sort = function(items) {");
          expect(buffer.lineForRow(2)).toBe("  if (items.length <= 1) return items;");
          expect(buffer.lineForRow(3)).toBe("    var pivot = items.shift(), current, left = [], right = [];");
          return expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [3, 0]]);
        });
      });
    });
    describe(".toggleLineCommentsInSelection()", function() {
      it("toggles comments on the selected lines", function() {
        editor.setSelectedBufferRange([[4, 5], [7, 5]]);
        editor.toggleLineCommentsInSelection();
        expect(buffer.lineForRow(4)).toBe("    // while(items.length > 0) {");
        expect(buffer.lineForRow(5)).toBe("    //   current = items.shift();");
        expect(buffer.lineForRow(6)).toBe("    //   current < pivot ? left.push(current) : right.push(current);");
        expect(buffer.lineForRow(7)).toBe("    // }");
        expect(editor.getSelectedBufferRange()).toEqual([[4, 8], [7, 8]]);
        editor.toggleLineCommentsInSelection();
        expect(buffer.lineForRow(4)).toBe("    while(items.length > 0) {");
        expect(buffer.lineForRow(5)).toBe("      current = items.shift();");
        expect(buffer.lineForRow(6)).toBe("      current < pivot ? left.push(current) : right.push(current);");
        return expect(buffer.lineForRow(7)).toBe("    }");
      });
      it("does not comment the last line of a non-empty selection if it ends at column 0", function() {
        editor.setSelectedBufferRange([[4, 5], [7, 0]]);
        editor.toggleLineCommentsInSelection();
        expect(buffer.lineForRow(4)).toBe("    // while(items.length > 0) {");
        expect(buffer.lineForRow(5)).toBe("    //   current = items.shift();");
        expect(buffer.lineForRow(6)).toBe("    //   current < pivot ? left.push(current) : right.push(current);");
        return expect(buffer.lineForRow(7)).toBe("    }");
      });
      it("uncomments lines if all lines match the comment regex", function() {
        editor.setSelectedBufferRange([[0, 0], [0, 1]]);
        editor.toggleLineCommentsInSelection();
        expect(buffer.lineForRow(0)).toBe("// var quicksort = function () {");
        editor.setSelectedBufferRange([[0, 0], [2, Infinity]]);
        editor.toggleLineCommentsInSelection();
        expect(buffer.lineForRow(0)).toBe("// // var quicksort = function () {");
        expect(buffer.lineForRow(1)).toBe("//   var sort = function(items) {");
        expect(buffer.lineForRow(2)).toBe("//     if (items.length <= 1) return items;");
        editor.setSelectedBufferRange([[0, 0], [2, Infinity]]);
        editor.toggleLineCommentsInSelection();
        expect(buffer.lineForRow(0)).toBe("// var quicksort = function () {");
        expect(buffer.lineForRow(1)).toBe("  var sort = function(items) {");
        expect(buffer.lineForRow(2)).toBe("    if (items.length <= 1) return items;");
        editor.setSelectedBufferRange([[0, 0], [0, Infinity]]);
        editor.toggleLineCommentsInSelection();
        return expect(buffer.lineForRow(0)).toBe("var quicksort = function () {");
      });
      it("uncomments commented lines separated by an empty line", function() {
        editor.setSelectedBufferRange([[0, 0], [1, Infinity]]);
        editor.toggleLineCommentsInSelection();
        expect(buffer.lineForRow(0)).toBe("// var quicksort = function () {");
        expect(buffer.lineForRow(1)).toBe("//   var sort = function(items) {");
        buffer.insert([0, Infinity], '\n');
        editor.setSelectedBufferRange([[0, 0], [2, Infinity]]);
        editor.toggleLineCommentsInSelection();
        expect(buffer.lineForRow(0)).toBe("var quicksort = function () {");
        expect(buffer.lineForRow(1)).toBe("");
        return expect(buffer.lineForRow(2)).toBe("  var sort = function(items) {");
      });
      it("preserves selection emptiness", function() {
        editor.setCursorBufferPosition([4, 0]);
        editor.toggleLineCommentsInSelection();
        return expect(editor.getSelection().isEmpty()).toBeTruthy();
      });
      it("does not explode if the current language mode has no comment regex", function() {
        editor.destroy();
        waitsForPromise(function() {
          return atom.workspace.open(null, {
            autoIndent: false
          }).then(function(o) {
            return editor = o;
          });
        });
        return runs(function() {
          editor.setSelectedBufferRange([[4, 5], [4, 5]]);
          editor.toggleLineCommentsInSelection();
          return expect(buffer.lineForRow(4)).toBe("    while(items.length > 0) {");
        });
      });
      it("uncomments when the line lacks the trailing whitespace in the comment regex", function() {
        editor.setCursorBufferPosition([10, 0]);
        editor.toggleLineCommentsInSelection();
        expect(buffer.lineForRow(10)).toBe("// ");
        expect(editor.getSelectedBufferRange()).toEqual([[10, 3], [10, 3]]);
        editor.backspace();
        expect(buffer.lineForRow(10)).toBe("//");
        editor.toggleLineCommentsInSelection();
        expect(buffer.lineForRow(10)).toBe("");
        return expect(editor.getSelectedBufferRange()).toEqual([[10, 0], [10, 0]]);
      });
      return it("uncomments when the line has leading whitespace", function() {
        editor.setCursorBufferPosition([10, 0]);
        editor.toggleLineCommentsInSelection();
        expect(buffer.lineForRow(10)).toBe("// ");
        editor.moveCursorToBeginningOfLine();
        editor.insertText("  ");
        editor.setSelectedBufferRange([[10, 0], [10, 0]]);
        editor.toggleLineCommentsInSelection();
        return expect(buffer.lineForRow(10)).toBe("  ");
      });
    });
    describe(".undo() and .redo()", function() {
      it("undoes/redoes the last change", function() {
        editor.insertText("foo");
        editor.undo();
        expect(buffer.lineForRow(0)).not.toContain("foo");
        editor.redo();
        return expect(buffer.lineForRow(0)).toContain("foo");
      });
      it("batches the undo / redo of changes caused by multiple cursors", function() {
        editor.setCursorScreenPosition([0, 0]);
        editor.addCursorAtScreenPosition([1, 0]);
        editor.insertText("foo");
        editor.backspace();
        expect(buffer.lineForRow(0)).toContain("fovar");
        expect(buffer.lineForRow(1)).toContain("fo ");
        editor.undo();
        expect(buffer.lineForRow(0)).toContain("foo");
        expect(buffer.lineForRow(1)).toContain("foo");
        editor.redo();
        expect(buffer.lineForRow(0)).not.toContain("foo");
        return expect(buffer.lineForRow(0)).toContain("fovar");
      });
      it("restores the selected ranges after undo and redo", function() {
        var selections;
        editor.setSelectedBufferRanges([[[1, 6], [1, 10]], [[1, 22], [1, 27]]]);
        editor["delete"]();
        editor["delete"]();
        selections = editor.getSelections();
        expect(buffer.lineForRow(1)).toBe('  var = function( {');
        expect(editor.getSelectedBufferRanges()).toEqual([[[1, 6], [1, 6]], [[1, 17], [1, 17]]]);
        editor.undo();
        expect(editor.getSelectedBufferRanges()).toEqual([[[1, 6], [1, 6]], [[1, 18], [1, 18]]]);
        editor.undo();
        expect(editor.getSelectedBufferRanges()).toEqual([[[1, 6], [1, 10]], [[1, 22], [1, 27]]]);
        editor.redo();
        return expect(editor.getSelectedBufferRanges()).toEqual([[[1, 6], [1, 6]], [[1, 18], [1, 18]]]);
      });
      return xit("restores folds after undo and redo", function() {
        editor.foldBufferRow(1);
        editor.setSelectedBufferRange([[1, 0], [10, Infinity]], {
          preserveFolds: true
        });
        expect(editor.isFoldedAtBufferRow(1)).toBeTruthy();
        editor.insertText("\  // testing\n  function foo() {\n    return 1 + 2;\n  }");
        expect(editor.isFoldedAtBufferRow(1)).toBeFalsy();
        editor.foldBufferRow(2);
        editor.undo();
        expect(editor.isFoldedAtBufferRow(1)).toBeTruthy();
        expect(editor.isFoldedAtBufferRow(9)).toBeTruthy();
        expect(editor.isFoldedAtBufferRow(10)).toBeFalsy();
        editor.redo();
        expect(editor.isFoldedAtBufferRow(1)).toBeFalsy();
        return expect(editor.isFoldedAtBufferRow(2)).toBeTruthy();
      });
    });
    describe("begin/commitTransaction()", function() {
      return it("restores the selection when the transaction is undone/redone", function() {
        buffer.setText('1234');
        editor.setSelectedBufferRange([[0, 1], [0, 3]]);
        editor.beginTransaction();
        editor["delete"]();
        editor.moveCursorToEndOfLine();
        editor.insertText('5');
        expect(buffer.getText()).toBe('145');
        editor.commitTransaction();
        editor.undo();
        expect(buffer.getText()).toBe('1234');
        expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [0, 3]]);
        editor.redo();
        expect(buffer.getText()).toBe('145');
        return expect(editor.getSelectedBufferRange()).toEqual([[0, 3], [0, 3]]);
      });
    });
    return describe("when the buffer is changed (via its direct api, rather than via than edit session)", function() {
      it("moves the cursor so it is in the same relative position of the buffer", function() {
        var cursor1, cursor2, cursor3, _ref1;
        expect(editor.getCursorScreenPosition()).toEqual([0, 0]);
        editor.addCursorAtScreenPosition([0, 5]);
        editor.addCursorAtScreenPosition([1, 0]);
        _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1], cursor3 = _ref1[2];
        buffer.insert([0, 1], 'abc');
        expect(cursor1.getScreenPosition()).toEqual([0, 0]);
        expect(cursor2.getScreenPosition()).toEqual([0, 8]);
        return expect(cursor3.getScreenPosition()).toEqual([1, 0]);
      });
      it("does not destroy cursors or selections when a change encompasses them", function() {
        var cursor, selection;
        cursor = editor.getCursor();
        cursor.setBufferPosition([3, 3]);
        editor.buffer["delete"]([[3, 1], [3, 5]]);
        expect(cursor.getBufferPosition()).toEqual([3, 1]);
        expect(editor.getCursors().indexOf(cursor)).not.toBe(-1);
        selection = editor.getLastSelection();
        selection.setBufferRange([[3, 5], [3, 10]]);
        editor.buffer["delete"]([[3, 3], [3, 8]]);
        expect(selection.getBufferRange()).toEqual([[3, 3], [3, 5]]);
        return expect(editor.getSelections().indexOf(selection)).not.toBe(-1);
      });
      return it("merges cursors when the change causes them to overlap", function() {
        var cursor1, cursor2, cursor3, _ref1;
        editor.setCursorScreenPosition([0, 0]);
        editor.addCursorAtScreenPosition([0, 2]);
        editor.addCursorAtScreenPosition([1, 2]);
        _ref1 = editor.getCursors(), cursor1 = _ref1[0], cursor2 = _ref1[1], cursor3 = _ref1[2];
        expect(editor.getCursors().length).toBe(3);
        buffer["delete"]([[0, 0], [0, 2]]);
        expect(editor.getCursors().length).toBe(2);
        expect(editor.getCursors()).toEqual([cursor1, cursor3]);
        expect(cursor1.getBufferPosition()).toEqual([0, 0]);
        return expect(cursor3.getBufferPosition()).toEqual([1, 2]);
      });
    });
  });
  describe(".deleteLine()", function() {
    it("deletes the first line when the cursor is there", function() {
      var count, line1;
      editor.getCursor().moveToTop();
      line1 = buffer.lineForRow(1);
      count = buffer.getLineCount();
      expect(buffer.lineForRow(0)).not.toBe(line1);
      editor.deleteLine();
      expect(buffer.lineForRow(0)).toBe(line1);
      return expect(buffer.getLineCount()).toBe(count - 1);
    });
    it("deletes the last line when the cursor is there", function() {
      var count, newCount, secondToLastLine;
      count = buffer.getLineCount();
      secondToLastLine = buffer.lineForRow(count - 2);
      expect(buffer.lineForRow(count - 1)).not.toBe(secondToLastLine);
      editor.getCursor().moveToBottom();
      editor.deleteLine();
      newCount = buffer.getLineCount();
      expect(buffer.lineForRow(newCount - 1)).toBe(secondToLastLine);
      return expect(newCount).toBe(count - 1);
    });
    it("deletes whole lines when partial lines are selected", function() {
      var count, line2;
      editor.setSelectedBufferRange([[0, 2], [1, 2]]);
      line2 = buffer.lineForRow(2);
      count = buffer.getLineCount();
      expect(buffer.lineForRow(0)).not.toBe(line2);
      expect(buffer.lineForRow(1)).not.toBe(line2);
      editor.deleteLine();
      expect(buffer.lineForRow(0)).toBe(line2);
      return expect(buffer.getLineCount()).toBe(count - 2);
    });
    it("only deletes first line if only newline is selected on second line", function() {
      var count, line1;
      editor.setSelectedBufferRange([[0, 2], [1, 0]]);
      line1 = buffer.lineForRow(1);
      count = buffer.getLineCount();
      expect(buffer.lineForRow(0)).not.toBe(line1);
      editor.deleteLine();
      expect(buffer.lineForRow(0)).toBe(line1);
      return expect(buffer.getLineCount()).toBe(count - 1);
    });
    it("deletes the entire region when invoke on a folded region", function() {
      editor.foldBufferRow(1);
      editor.getCursor().moveToTop();
      editor.getCursor().moveDown();
      expect(buffer.getLineCount()).toBe(13);
      editor.deleteLine();
      return expect(buffer.getLineCount()).toBe(4);
    });
    it("deletes the entire file from the bottom up", function() {
      var count, line, _i;
      count = buffer.getLineCount();
      expect(count).toBeGreaterThan(0);
      for (line = _i = 0; 0 <= count ? _i < count : _i > count; line = 0 <= count ? ++_i : --_i) {
        editor.getCursor().moveToBottom();
        editor.deleteLine();
      }
      expect(buffer.getLineCount()).toBe(1);
      return expect(buffer.getText()).toBe('');
    });
    it("deletes the entire file from the top down", function() {
      var count, line, _i;
      count = buffer.getLineCount();
      expect(count).toBeGreaterThan(0);
      for (line = _i = 0; 0 <= count ? _i < count : _i > count; line = 0 <= count ? ++_i : --_i) {
        editor.getCursor().moveToTop();
        editor.deleteLine();
      }
      expect(buffer.getLineCount()).toBe(1);
      return expect(buffer.getText()).toBe('');
    });
    describe("when soft wrap is enabled", function() {
      return it("deletes the entire line that the cursor is on", function() {
        var count, line7;
        editor.setSoftWrap(true);
        editor.setEditorWidthInChars(10);
        editor.setCursorBufferPosition([6]);
        line7 = buffer.lineForRow(7);
        count = buffer.getLineCount();
        expect(buffer.lineForRow(6)).not.toBe(line7);
        editor.deleteLine();
        expect(buffer.lineForRow(6)).toBe(line7);
        return expect(buffer.getLineCount()).toBe(count - 1);
      });
    });
    return describe("when the line being deleted preceeds a fold, and the command is undone", function() {
      return it("restores the line and preserves the fold", function() {
        editor.setCursorBufferPosition([4]);
        editor.foldCurrentRow();
        expect(editor.isFoldedAtScreenRow(4)).toBeTruthy();
        editor.setCursorBufferPosition([3]);
        editor.deleteLine();
        expect(editor.isFoldedAtScreenRow(3)).toBeTruthy();
        expect(buffer.lineForRow(3)).toBe('    while(items.length > 0) {');
        editor.undo();
        expect(editor.isFoldedAtScreenRow(4)).toBeTruthy();
        return expect(buffer.lineForRow(3)).toBe('    var pivot = items.shift(), current, left = [], right = [];');
      });
    });
  });
  describe(".replaceSelectedText(options, fn)", function() {
    describe("when no text is selected", function() {
      return it("inserts the text returned from the function at the cursor position", function() {
        editor.replaceSelectedText({}, function() {
          return '123';
        });
        expect(buffer.lineForRow(0)).toBe('123var quicksort = function () {');
        editor.replaceSelectedText({
          selectWordIfEmpty: true
        }, function() {
          return 'var';
        });
        editor.setCursorBufferPosition([0]);
        expect(buffer.lineForRow(0)).toBe('var quicksort = function () {');
        editor.setCursorBufferPosition([10]);
        editor.replaceSelectedText(null, function() {
          return '';
        });
        return expect(buffer.lineForRow(10)).toBe('');
      });
    });
    return describe("when text is selected", function() {
      return it("replaces the selected text with the text returned from the function", function() {
        editor.setSelectedBufferRange([[0, 1], [0, 3]]);
        editor.replaceSelectedText({}, function() {
          return 'ia';
        });
        return expect(buffer.lineForRow(0)).toBe('via quicksort = function () {');
      });
    });
  });
  describe(".transpose()", function() {
    it("swaps two characters", function() {
      editor.buffer.setText("abc");
      editor.setCursorScreenPosition([0, 1]);
      editor.transpose();
      return expect(editor.lineForBufferRow(0)).toBe('bac');
    });
    return it("reverses a selection", function() {
      editor.buffer.setText("xabcz");
      editor.setSelectedBufferRange([[0, 1], [0, 4]]);
      editor.transpose();
      return expect(editor.lineForBufferRow(0)).toBe('xcbaz');
    });
  });
  describe(".upperCase()", function() {
    describe("when there is no selection", function() {
      return it("upper cases the current word", function() {
        editor.buffer.setText("aBc");
        editor.setCursorScreenPosition([0, 1]);
        editor.upperCase();
        expect(editor.lineForBufferRow(0)).toBe('ABC');
        return expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [0, 1]]);
      });
    });
    return describe("when there is a selection", function() {
      return it("upper cases the current selection", function() {
        editor.buffer.setText("abc");
        editor.setSelectedBufferRange([[0, 0], [0, 2]]);
        editor.upperCase();
        expect(editor.lineForBufferRow(0)).toBe('ABc');
        return expect(editor.getSelectedBufferRange()).toEqual([[0, 0], [0, 2]]);
      });
    });
  });
  describe(".lowerCase()", function() {
    describe("when there is no selection", function() {
      return it("lower cases the current word", function() {
        editor.buffer.setText("aBC");
        editor.setCursorScreenPosition([0, 1]);
        editor.lowerCase();
        expect(editor.lineForBufferRow(0)).toBe('abc');
        return expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [0, 1]]);
      });
    });
    return describe("when there is a selection", function() {
      return it("lower cases the current selection", function() {
        editor.buffer.setText("ABC");
        editor.setSelectedBufferRange([[0, 0], [0, 2]]);
        editor.lowerCase();
        expect(editor.lineForBufferRow(0)).toBe('abC');
        return expect(editor.getSelectedBufferRange()).toEqual([[0, 0], [0, 2]]);
      });
    });
  });
  describe("soft-tabs detection", function() {
    return it("assigns soft / hard tabs based on the contents of the buffer, or uses the default if unknown", function() {
      waitsForPromise(function() {
        return atom.workspace.open('sample.js', {
          softTabs: false
        }).then(function(editor) {
          return expect(editor.getSoftTabs()).toBeTruthy();
        });
      });
      waitsForPromise(function() {
        return atom.workspace.open('sample-with-tabs.coffee', {
          softTabs: true
        }).then(function(editor) {
          return expect(editor.getSoftTabs()).toBeFalsy();
        });
      });
      waitsForPromise(function() {
        return atom.workspace.open('sample-with-tabs-and-initial-comment.js', {
          softTabs: true
        }).then(function(editor) {
          return expect(editor.getSoftTabs()).toBeFalsy();
        });
      });
      return waitsForPromise(function() {
        return atom.workspace.open(null, {
          softTabs: false
        }).then(function(editor) {
          return expect(editor.getSoftTabs()).toBeFalsy();
        });
      });
    });
  });
  describe(".indentLevelForLine(line)", function() {
    it("returns the indent level when the line has only leading whitespace", function() {
      expect(editor.indentLevelForLine("    hello")).toBe(2);
      return expect(editor.indentLevelForLine("   hello")).toBe(1.5);
    });
    it("returns the indent level when the line has only leading tabs", function() {
      return expect(editor.indentLevelForLine("\t\thello")).toBe(2);
    });
    return it("returns the indent level when the line has mixed leading whitespace and tabs", function() {
      expect(editor.indentLevelForLine("\t  hello")).toBe(2);
      expect(editor.indentLevelForLine("  \thello")).toBe(2);
      expect(editor.indentLevelForLine("  \t hello")).toBe(2.5);
      return expect(editor.indentLevelForLine("  \t \thello")).toBe(3.5);
    });
  });
  describe("when the buffer is reloaded", function() {
    return it("preserves the current cursor position", function() {
      editor.setCursorScreenPosition([0, 1]);
      editor.buffer.reload();
      return expect(editor.getCursorScreenPosition()).toEqual([0, 1]);
    });
  });
  describe("when a better-matched grammar is added to syntax", function() {
    return it("switches to the better-matched grammar and re-tokenizes the buffer", function() {
      var jsGrammar;
      editor.destroy();
      jsGrammar = atom.syntax.selectGrammar('a.js');
      atom.syntax.removeGrammar(jsGrammar);
      waitsForPromise(function() {
        return atom.workspace.open('sample.js', {
          autoIndent: false
        }).then(function(o) {
          return editor = o;
        });
      });
      return runs(function() {
        expect(editor.getGrammar()).toBe(atom.syntax.nullGrammar);
        expect(editor.lineForScreenRow(0).tokens.length).toBe(1);
        atom.syntax.addGrammar(jsGrammar);
        expect(editor.getGrammar()).toBe(jsGrammar);
        return expect(editor.lineForScreenRow(0).tokens.length).toBeGreaterThan(1);
      });
    });
  });
  describe("auto-indent", function() {
    var copyText;
    copyText = function(text, _arg) {
      var endColumn, numberOfNewlines, startColumn, _ref1, _ref2;
      startColumn = (_arg != null ? _arg : {}).startColumn;
      if (startColumn == null) {
        startColumn = 0;
      }
      editor.setCursorBufferPosition([0, 0]);
      editor.insertText(text);
      numberOfNewlines = (_ref1 = text.match(/\n/g)) != null ? _ref1.length : void 0;
      endColumn = (_ref2 = text.match(/[^\n]*$/)[0]) != null ? _ref2.length : void 0;
      editor.getSelection().setBufferRange([[0, startColumn], [numberOfNewlines, endColumn]]);
      return editor.cutSelectedText();
    };
    describe("editor.autoIndent", function() {
      describe("when editor.autoIndent is false (default)", function() {
        return describe("when `indent` is triggered", function() {
          return it("does not auto-indent the line", function() {
            editor.setCursorBufferPosition([1, 30]);
            editor.insertText("\n ");
            expect(editor.lineForBufferRow(2)).toBe(" ");
            atom.config.set("editor.autoIndent", false);
            editor.indent();
            return expect(editor.lineForBufferRow(2)).toBe("  ");
          });
        });
      });
      return describe("when editor.autoIndent is true", function() {
        beforeEach(function() {
          return atom.config.set("editor.autoIndent", true);
        });
        describe("when `indent` is triggered", function() {
          return it("auto-indents the line", function() {
            editor.setCursorBufferPosition([1, 30]);
            editor.insertText("\n ");
            expect(editor.lineForBufferRow(2)).toBe(" ");
            atom.config.set("editor.autoIndent", true);
            editor.indent();
            return expect(editor.lineForBufferRow(2)).toBe("    ");
          });
        });
        describe("when a newline is added", function() {
          describe("when the line preceding the newline adds a new level of indentation", function() {
            return it("indents the newline to one additional level of indentation beyond the preceding line", function() {
              editor.setCursorBufferPosition([1, Infinity]);
              editor.insertText('\n');
              return expect(editor.indentationForBufferRow(2)).toBe(editor.indentationForBufferRow(1) + 1);
            });
          });
          describe("when the line preceding the newline does't add a level of indentation", function() {
            return it("indents the new line to the same level a as the preceding line", function() {
              editor.setCursorBufferPosition([5, 14]);
              editor.insertText('\n');
              return expect(editor.indentationForBufferRow(6)).toBe(editor.indentationForBufferRow(5));
            });
          });
          describe("when the line preceding the newline is a comment", function() {
            return it("maintains the indent of the commented line", function() {
              editor.setCursorBufferPosition([0, 0]);
              editor.insertText('    //');
              editor.setCursorBufferPosition([0, Infinity]);
              editor.insertText('\n');
              return expect(editor.indentationForBufferRow(1)).toBe(2);
            });
          });
          it("does not indent the line preceding the newline", function() {
            editor.setCursorBufferPosition([2, 0]);
            editor.insertText('  var this-line-should-be-indented-more\n');
            expect(editor.indentationForBufferRow(1)).toBe(1);
            atom.config.set("editor.autoIndent", true);
            editor.setCursorBufferPosition([2, Infinity]);
            editor.insertText('\n');
            expect(editor.indentationForBufferRow(1)).toBe(1);
            return expect(editor.indentationForBufferRow(2)).toBe(1);
          });
          return describe("when the cursor is before whitespace", function() {
            return it("retains the whitespace following the cursor on the new line", function() {
              editor.setText("  var sort = function() {}");
              editor.setCursorScreenPosition([0, 23]);
              editor.insertNewline();
              expect(buffer.lineForRow(0)).toBe('  var sort = function()');
              expect(buffer.lineForRow(1)).toBe('   {}');
              return expect(editor.getCursorScreenPosition()).toEqual([1, 2]);
            });
          });
        });
        describe("when inserted text matches a decrease indent pattern", function() {
          describe("when the preceding line matches an increase indent pattern", function() {
            return it("decreases the indentation to match that of the preceding line", function() {
              editor.setCursorBufferPosition([1, Infinity]);
              editor.insertText('\n');
              expect(editor.indentationForBufferRow(2)).toBe(editor.indentationForBufferRow(1) + 1);
              editor.insertText('}');
              return expect(editor.indentationForBufferRow(2)).toBe(editor.indentationForBufferRow(1));
            });
          });
          return describe("when the preceding line doesn't match an increase indent pattern", function() {
            it("decreases the indentation to be one level below that of the preceding line", function() {
              editor.setCursorBufferPosition([3, Infinity]);
              editor.insertText('\n    ');
              expect(editor.indentationForBufferRow(4)).toBe(editor.indentationForBufferRow(3));
              editor.insertText('}');
              return expect(editor.indentationForBufferRow(4)).toBe(editor.indentationForBufferRow(3) - 1);
            });
            return it("doesn't break when decreasing the indentation on a row that has no indentation", function() {
              editor.setCursorBufferPosition([12, Infinity]);
              editor.insertText("\n}; # too many closing brackets!");
              return expect(editor.lineForBufferRow(13)).toBe("}; # too many closing brackets!");
            });
          });
        });
        describe("when inserted text does not match a decrease indent pattern", function() {
          return it("does not decrease the indentation", function() {
            editor.setCursorBufferPosition([12, 0]);
            editor.insertText('  ');
            expect(editor.lineForBufferRow(12)).toBe('  };');
            editor.insertText('\t\t');
            return expect(editor.lineForBufferRow(12)).toBe('  \t\t};');
          });
        });
        return describe("when the current line does not match a decrease indent pattern", function() {
          return it("leaves the line unchanged", function() {
            editor.setCursorBufferPosition([2, 4]);
            expect(editor.indentationForBufferRow(2)).toBe(editor.indentationForBufferRow(1) + 1);
            editor.insertText('foo');
            return expect(editor.indentationForBufferRow(2)).toBe(editor.indentationForBufferRow(1) + 1);
          });
        });
      });
    });
    describe("editor.normalizeIndentOnPaste", function() {
      beforeEach(function() {
        return atom.config.set('editor.normalizeIndentOnPaste', true);
      });
      it("does not normalize the indentation level of the text when editor.normalizeIndentOnPaste is false", function() {
        copyText("   function() {\nvar cool = 1;\n  }\n");
        atom.config.set('editor.normalizeIndentOnPaste', false);
        editor.setCursorBufferPosition([5, 2]);
        editor.pasteText();
        expect(editor.lineForBufferRow(5)).toBe("     function() {");
        expect(editor.lineForBufferRow(6)).toBe("var cool = 1;");
        return expect(editor.lineForBufferRow(7)).toBe("  }");
      });
      describe("when the inserted text contains no newlines", function() {
        it("does not adjust the indentation level of the text", function() {
          editor.setCursorBufferPosition([5, 2]);
          editor.insertText("foo", {
            indentBasis: 5
          });
          return expect(editor.lineForBufferRow(5)).toBe("  foo    current = items.shift();");
        });
        return it("does not adjust the whitespace if there are preceding characters", function() {
          copyText(" foo");
          editor.setCursorBufferPosition([5, 30]);
          editor.pasteText();
          return expect(editor.lineForBufferRow(5)).toBe("      current = items.shift(); foo");
        });
      });
      return describe("when the inserted text contains newlines", function() {
        describe("when the cursor is preceded only by whitespace characters", function() {
          return it("normalizes indented lines to the cursor's current indentation level", function() {
            copyText("    while (true) {\n      foo();\n    }\n", {
              startColumn: 2
            });
            editor.setCursorBufferPosition([3, 4]);
            editor.pasteText();
            expect(editor.lineForBufferRow(3)).toBe("    while (true) {");
            expect(editor.lineForBufferRow(4)).toBe("      foo();");
            expect(editor.lineForBufferRow(5)).toBe("    }");
            return expect(editor.lineForBufferRow(6)).toBe("var pivot = items.shift(), current, left = [], right = [];");
          });
        });
        return describe("when the cursor is preceded by non-whitespace characters", function() {
          return it("normalizes the indentation level of all lines based on the level of the existing first line", function() {
            copyText("    while (true) {\n      foo();\n    }\n", {
              startColumn: 0
            });
            editor.setCursorBufferPosition([1, Infinity]);
            editor.pasteText();
            expect(editor.lineForBufferRow(1)).toBe("  var sort = function(items) {while (true) {");
            expect(editor.lineForBufferRow(2)).toBe("    foo();");
            expect(editor.lineForBufferRow(3)).toBe("  }");
            return expect(editor.lineForBufferRow(4)).toBe("");
          });
        });
      });
    });
    return it("autoIndentSelectedRows auto-indents the selection", function() {
      editor.setCursorBufferPosition([2, 0]);
      editor.insertText("function() {\ninside=true\n}\n  i=1\n");
      editor.getSelection().setBufferRange([[2, 0], [6, 0]]);
      editor.autoIndentSelectedRows();
      expect(editor.lineForBufferRow(2)).toBe("    function() {");
      expect(editor.lineForBufferRow(3)).toBe("      inside=true");
      expect(editor.lineForBufferRow(4)).toBe("    }");
      return expect(editor.lineForBufferRow(5)).toBe("    i=1");
    });
  });
  describe("soft and hard tabs", function() {
    return it("resets the tab style when tokenization is complete", function() {
      editor.destroy();
      atom.project.open('sample-with-tabs-and-leading-comment.coffee').then(function(o) {
        return editor = o;
      });
      expect(editor.softTabs).toBe(true);
      waitsForPromise(function() {
        return atom.packages.activatePackage('language-coffee-script');
      });
      return runs(function() {
        return expect(editor.softTabs).toBe(false);
      });
    });
  });
  describe(".destroy()", function() {
    return it("destroys all markers associated with the edit session", function() {
      expect(buffer.getMarkerCount()).toBeGreaterThan(0);
      editor.destroy();
      return expect(buffer.getMarkerCount()).toBe(0);
    });
  });
  describe(".joinLines()", function() {
    describe("when no text is selected", function() {
      describe("when the line below isn't empty", function() {
        return it("joins the line below with the current line separated by a space and moves the cursor to the start of line that was moved up", function() {
          editor.joinLines();
          expect(editor.lineForBufferRow(0)).toBe('var quicksort = function () { var sort = function(items) {');
          return expect(editor.getCursorBufferPosition()).toEqual([0, 30]);
        });
      });
      describe("when the line below is empty", function() {
        return it("deletes the line below and moves the cursor to the end of the line", function() {
          editor.setCursorBufferPosition([9]);
          editor.joinLines();
          expect(editor.lineForBufferRow(9)).toBe('  };');
          expect(editor.lineForBufferRow(10)).toBe('  return sort(Array.apply(this, arguments));');
          return expect(editor.getCursorBufferPosition()).toEqual([9, 4]);
        });
      });
      return describe("when the cursor is on the last row", function() {
        return it("does nothing", function() {
          editor.setCursorBufferPosition([Infinity, Infinity]);
          editor.joinLines();
          return expect(editor.lineForBufferRow(12)).toBe('};');
        });
      });
    });
    return describe("when text is selected", function() {
      describe("when the selection does not span multiple lines", function() {
        return it("joins the line below with the current line separated by a space and retains the selected text", function() {
          editor.setSelectedBufferRange([[0, 1], [0, 3]]);
          editor.joinLines();
          expect(editor.lineForBufferRow(0)).toBe('var quicksort = function () { var sort = function(items) {');
          return expect(editor.getSelectedBufferRange()).toEqual([[0, 1], [0, 3]]);
        });
      });
      return describe("when the selection spans multiple lines", function() {
        return it("joins all selected lines separated by a space and retains the selected text", function() {
          editor.setSelectedBufferRange([[9, 3], [12, 1]]);
          editor.joinLines();
          expect(editor.lineForBufferRow(9)).toBe('  }; return sort(Array.apply(this, arguments)); };');
          return expect(editor.getSelectedBufferRange()).toEqual([[9, 3], [9, 49]]);
        });
      });
    });
  });
  describe(".duplicateLines()", function() {
    it("for each selection, duplicates all buffer lines intersected by the selection", function() {
      editor.foldBufferRow(4);
      editor.setCursorBufferPosition([2, 5]);
      editor.addSelectionForBufferRange([[3, 0], [8, 0]], {
        preserveFolds: true
      });
      editor.duplicateLines();
      expect(editor.getTextInBufferRange([[2, 0], [13, 5]])).toBe("\    if (items.length <= 1) return items;\n    if (items.length <= 1) return items;\n    var pivot = items.shift(), current, left = [], right = [];\n    while(items.length > 0) {\n      current = items.shift();\n      current < pivot ? left.push(current) : right.push(current);\n    }\n    var pivot = items.shift(), current, left = [], right = [];\n    while(items.length > 0) {\n      current = items.shift();\n      current < pivot ? left.push(current) : right.push(current);\n    }");
      expect(editor.getSelectedBufferRanges()).toEqual([[[3, 5], [3, 5]], [[9, 0], [14, 0]]]);
      expect(editor.lineForScreenRow(5).fold).toBeDefined();
      expect(editor.lineForScreenRow(7).fold).toBeDefined();
      expect(editor.lineForScreenRow(7).text).toBe("    while(items.length > 0) {");
      return expect(editor.lineForScreenRow(8).text).toBe("    return sort(left).concat(pivot).concat(sort(right));");
    });
    it("duplicates all folded lines for empty selections on folded lines", function() {
      editor.foldBufferRow(4);
      editor.setCursorBufferPosition([4, 0]);
      editor.duplicateLines();
      expect(editor.getTextInBufferRange([[2, 0], [11, 5]])).toBe("\    if (items.length <= 1) return items;\n    var pivot = items.shift(), current, left = [], right = [];\n    while(items.length > 0) {\n      current = items.shift();\n      current < pivot ? left.push(current) : right.push(current);\n    }\n    while(items.length > 0) {\n      current = items.shift();\n      current < pivot ? left.push(current) : right.push(current);\n    }");
      return expect(editor.getSelectedBufferRange()).toEqual([[8, 0], [8, 0]]);
    });
    return it("can duplicate the last line of the buffer", function() {
      editor.setSelectedBufferRange([[11, 0], [12, 2]]);
      editor.duplicateLines();
      expect(editor.getTextInBufferRange([[11, 0], [14, 2]])).toBe("\  return sort(Array.apply(this, arguments));\n};\n  return sort(Array.apply(this, arguments));\n};");
      return expect(editor.getSelectedBufferRange()).toEqual([[13, 0], [14, 2]]);
    });
  });
  describe(".shouldPromptToSave()", function() {
    return it("returns false when an edit session's buffer is in use by more than one session", function() {
      var editor2;
      jasmine.unspy(editor, 'shouldPromptToSave');
      expect(editor.shouldPromptToSave()).toBeFalsy();
      buffer.setText('changed');
      expect(editor.shouldPromptToSave()).toBeTruthy();
      editor2 = null;
      waitsForPromise(function() {
        return atom.project.open('sample.js', {
          autoIndent: false
        }).then(function(o) {
          return editor2 = o;
        });
      });
      return runs(function() {
        expect(editor.shouldPromptToSave()).toBeFalsy();
        editor2.destroy();
        return expect(editor.shouldPromptToSave()).toBeTruthy();
      });
    });
  });
  describe("when the edit session contains surrogate pair characters", function() {
    it("correctly backspaces over them", function() {
      editor.setText('\uD835\uDF97\uD835\uDF97\uD835\uDF97');
      editor.moveCursorToBottom();
      editor.backspace();
      expect(editor.getText()).toBe('\uD835\uDF97\uD835\uDF97');
      editor.backspace();
      expect(editor.getText()).toBe('\uD835\uDF97');
      editor.backspace();
      return expect(editor.getText()).toBe('');
    });
    it("correctly deletes over them", function() {
      editor.setText('\uD835\uDF97\uD835\uDF97\uD835\uDF97');
      editor.moveCursorToTop();
      editor["delete"]();
      expect(editor.getText()).toBe('\uD835\uDF97\uD835\uDF97');
      editor["delete"]();
      expect(editor.getText()).toBe('\uD835\uDF97');
      editor["delete"]();
      return expect(editor.getText()).toBe('');
    });
    return it("correctly moves over them", function() {
      editor.setText('\uD835\uDF97\uD835\uDF97\uD835\uDF97\n');
      editor.moveCursorToTop();
      editor.moveCursorRight();
      expect(editor.getCursorBufferPosition()).toEqual([0, 2]);
      editor.moveCursorRight();
      expect(editor.getCursorBufferPosition()).toEqual([0, 4]);
      editor.moveCursorRight();
      expect(editor.getCursorBufferPosition()).toEqual([0, 6]);
      editor.moveCursorRight();
      expect(editor.getCursorBufferPosition()).toEqual([1, 0]);
      editor.moveCursorLeft();
      expect(editor.getCursorBufferPosition()).toEqual([0, 6]);
      editor.moveCursorLeft();
      expect(editor.getCursorBufferPosition()).toEqual([0, 4]);
      editor.moveCursorLeft();
      expect(editor.getCursorBufferPosition()).toEqual([0, 2]);
      editor.moveCursorLeft();
      return expect(editor.getCursorBufferPosition()).toEqual([0, 0]);
    });
  });
  describe(".setIndentationForBufferRow", function() {
    describe("when the editor uses soft tabs but the row has hard tabs", function() {
      return it("only replaces whitespace charachters", function() {
        editor.setSoftWrap(true);
        editor.setText("\t1\n\t2");
        editor.setCursorBufferPosition([0, 0]);
        editor.setIndentationForBufferRow(0, 2);
        return expect(editor.getText()).toBe("    1\n\t2");
      });
    });
    return describe("when the indentation level is a non-integer", function() {
      return it("does not throw an exception", function() {
        editor.setSoftWrap(true);
        editor.setText("\t1\n\t2");
        editor.setCursorBufferPosition([0, 0]);
        editor.setIndentationForBufferRow(0, 2.1);
        return expect(editor.getText()).toBe("    1\n\t2");
      });
    });
  });
  describe(".reloadGrammar()", function() {
    beforeEach(function() {
      return waitsForPromise(function() {
        return atom.packages.activatePackage('language-coffee-script');
      });
    });
    return it("updates the grammar based on grammar overrides", function() {
      expect(editor.getGrammar().name).toBe('JavaScript');
      atom.syntax.setGrammarOverrideForPath(editor.getPath(), 'source.coffee');
      editor.reloadGrammar();
      return expect(editor.getGrammar().name).toBe('CoffeeScript');
    });
  });
  describe("when the editor's grammar has an injection selector", function() {
    beforeEach(function() {
      waitsForPromise(function() {
        return atom.packages.activatePackage('language-text');
      });
      return waitsForPromise(function() {
        return atom.packages.activatePackage('language-javascript');
      });
    });
    it("includes the grammar's patterns when the selector matches the current scope in other grammars", function() {
      waitsForPromise(function() {
        return atom.packages.activatePackage('language-hyperlink');
      });
      return runs(function() {
        var grammar, tokens;
        grammar = atom.syntax.selectGrammar("text.js");
        tokens = grammar.tokenizeLine("var i; // http://github.com").tokens;
        expect(tokens[0].value).toBe("var");
        expect(tokens[0].scopes).toEqual(["source.js", "storage.modifier.js"]);
        expect(tokens[6].value).toBe("http://github.com");
        return expect(tokens[6].scopes).toEqual(["source.js", "comment.line.double-slash.js", "markup.underline.link.http.hyperlink"]);
      });
    });
    return describe("when the grammar is added", function() {
      it("retokenizes existing buffers that contain tokens that match the injection selector", function() {
        waitsForPromise(function() {
          return atom.workspace.open('sample.js').then(function(o) {
            return editor = o;
          });
        });
        runs(function() {
          var tokens;
          editor.setText("// http://github.com");
          tokens = editor.lineForScreenRow(0).tokens;
          expect(tokens[1].value).toBe(" http://github.com");
          return expect(tokens[1].scopes).toEqual(["source.js", "comment.line.double-slash.js"]);
        });
        waitsForPromise(function() {
          return atom.packages.activatePackage('language-hyperlink');
        });
        return runs(function() {
          var tokens;
          tokens = editor.lineForScreenRow(0).tokens;
          expect(tokens[2].value).toBe("http://github.com");
          return expect(tokens[2].scopes).toEqual(["source.js", "comment.line.double-slash.js", "markup.underline.link.http.hyperlink"]);
        });
      });
      return describe("when the grammar is updated", function() {
        return it("retokenizes existing buffers that contain tokens that match the injection selector", function() {
          waitsForPromise(function() {
            return atom.workspace.open('sample.js').then(function(o) {
              return editor = o;
            });
          });
          runs(function() {
            var tokens;
            editor.setText("// SELECT * FROM OCTOCATS");
            tokens = editor.lineForScreenRow(0).tokens;
            expect(tokens[1].value).toBe(" SELECT * FROM OCTOCATS");
            return expect(tokens[1].scopes).toEqual(["source.js", "comment.line.double-slash.js"]);
          });
          waitsForPromise(function() {
            return atom.packages.activatePackage('package-with-injection-selector');
          });
          runs(function() {
            var tokens;
            tokens = editor.lineForScreenRow(0).tokens;
            expect(tokens[1].value).toBe(" SELECT * FROM OCTOCATS");
            return expect(tokens[1].scopes).toEqual(["source.js", "comment.line.double-slash.js"]);
          });
          waitsForPromise(function() {
            return atom.packages.activatePackage('language-sql');
          });
          return runs(function() {
            var tokens;
            tokens = editor.lineForScreenRow(0).tokens;
            expect(tokens[2].value).toBe("SELECT");
            return expect(tokens[2].scopes).toEqual(["source.js", "comment.line.double-slash.js", "keyword.other.DML.sql"]);
          });
        });
      });
    });
  });
  describe(".normalizeTabsInBufferRange()", function() {
    return it("normalizes tabs depending on the editor's soft tab/tab length settings", function() {
      editor.setTabLength(1);
      editor.setSoftTabs(true);
      editor.setText('\t\t\t');
      editor.normalizeTabsInBufferRange([[0, 0], [0, 1]]);
      expect(editor.getText()).toBe(' \t\t');
      editor.setTabLength(2);
      editor.normalizeTabsInBufferRange([[0, 0], [Infinity, Infinity]]);
      expect(editor.getText()).toBe('     ');
      editor.setSoftTabs(false);
      editor.normalizeTabsInBufferRange([[0, 0], [Infinity, Infinity]]);
      return expect(editor.getText()).toBe('     ');
    });
  });
  describe(".scrollToCursorPosition()", function() {
    return it("scrolls the last cursor into view, centering around the cursor if possible and the 'center' option isn't false", function() {
      editor.setCursorScreenPosition([8, 8]);
      editor.setLineHeightInPixels(10);
      editor.setDefaultCharWidth(10);
      editor.setHeight(60);
      editor.setWidth(50);
      editor.setHorizontalScrollbarHeight(0);
      expect(editor.getScrollTop()).toBe(0);
      expect(editor.getScrollLeft()).toBe(0);
      editor.scrollToCursorPosition();
      expect(editor.getScrollTop()).toBe((8.5 * 10) - 30);
      expect(editor.getScrollBottom()).toBe((8.5 * 10) + 30);
      expect(editor.getScrollRight()).toBe((9 + editor.getHorizontalScrollMargin()) * 10);
      editor.setScrollTop(0);
      editor.scrollToCursorPosition({
        center: false
      });
      return expect(editor.getScrollBottom()).toBe((9 + editor.getVerticalScrollMargin()) * 10);
    });
  });
  describe(".pageUp/Down()", function() {
    return it("scrolls one screen height up or down and moves the cursor one page length", function() {
      editor.manageScrollPosition = true;
      editor.setLineHeightInPixels(10);
      editor.setHeight(50);
      expect(editor.getScrollHeight()).toBe(130);
      expect(editor.getCursorBufferPosition().row).toBe(0);
      editor.pageDown();
      expect(editor.getScrollTop()).toBe(50);
      expect(editor.getCursorBufferPosition().row).toBe(5);
      editor.pageDown();
      expect(editor.getScrollTop()).toBe(80);
      expect(editor.getCursorBufferPosition().row).toBe(10);
      editor.pageUp();
      expect(editor.getScrollTop()).toBe(30);
      expect(editor.getCursorBufferPosition().row).toBe(5);
      editor.pageUp();
      expect(editor.getScrollTop()).toBe(0);
      return expect(editor.getCursorBufferPosition().row).toBe(0);
    });
  });
  return describe(".selectPageUp/Down()", function() {
    return it("selects one screen height of text up or down", function() {
      editor.manageScrollPosition = true;
      editor.setLineHeightInPixels(10);
      editor.setHeight(50);
      expect(editor.getScrollHeight()).toBe(130);
      expect(editor.getCursorBufferPosition().row).toBe(0);
      editor.selectPageDown();
      expect(editor.getScrollTop()).toBe(30);
      expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [5, 0]]]);
      editor.selectPageDown();
      expect(editor.getScrollTop()).toBe(80);
      expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [10, 0]]]);
      editor.selectPageDown();
      expect(editor.getScrollTop()).toBe(80);
      expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [12, 2]]]);
      editor.moveCursorToBottom();
      editor.selectPageUp();
      expect(editor.getScrollTop()).toBe(50);
      expect(editor.getSelectedBufferRanges()).toEqual([[[7, 0], [12, 2]]]);
      editor.selectPageUp();
      expect(editor.getScrollTop()).toBe(0);
      expect(editor.getSelectedBufferRanges()).toEqual([[[2, 0], [12, 2]]]);
      editor.selectPageUp();
      expect(editor.getScrollTop()).toBe(0);
      return expect(editor.getSelectedBufferRanges()).toEqual([[[0, 0], [12, 2]]]);
    });
  });
});
