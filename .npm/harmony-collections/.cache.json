{"_id":"harmony-collections","_rev":"69-29e03c1dc107014bc2d399e1b1f0fe89","name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available, with non-leaky O(1) lookup WeakMaps","dist-tags":{"latest":"0.3.8"},"versions":{"0.0.1":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","version":"0.0.1","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.0.1","_engineSupported":false,"_npmVersion":"1.1.0-alpha-6","_nodeVersion":"v0.7.0-pre","_defaultsLoaded":true,"dist":{"shasum":"8fbd15a16e25f78928616ba9af787fb209c51f2e","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.0.1.tgz"},"maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.0.2":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","version":"0.0.2","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.0.2","_engineSupported":false,"_npmVersion":"1.1.0-alpha-6","_nodeVersion":"v0.7.0-pre","_defaultsLoaded":true,"dist":{"shasum":"bdee934970bd8e103194e909e8f4447e8420c4b5","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.0.2.tgz"},"maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.0.3":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","version":"0.0.3","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.0.3","_engineSupported":false,"_npmVersion":"1.1.0-alpha-6","_nodeVersion":"v0.7.0-pre","_defaultsLoaded":true,"dist":{"shasum":"32b180c81ba7ff0a79325b88e8e28450a15f7235","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.0.3.tgz"},"maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.0.4":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","version":"0.0.4","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.0.4","_engineSupported":false,"_npmVersion":"1.1.0-alpha-6","_nodeVersion":"v0.7.0-pre","_defaultsLoaded":true,"dist":{"shasum":"f85b75a6835e9b371f9d1d7d3135cc6f5dbe6630","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.0.4.tgz"},"maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.0.5":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","version":"0.0.5","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.0.5","_engineSupported":false,"_npmVersion":"1.1.0-alpha-6","_nodeVersion":"v0.7.0-pre","_defaultsLoaded":true,"dist":{"shasum":"5b18d7b310d725bd5f6864bfe6484be35f64fcbb","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.0.5.tgz"},"maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.0.6":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","version":"0.0.6","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.0.6","_engineSupported":false,"_npmVersion":"1.1.0-alpha-6","_nodeVersion":"v0.7.0-pre","_defaultsLoaded":true,"dist":{"shasum":"671e7bc6a4f23dd772e89a205f63dc1cc9063de0","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.0.6.tgz"},"maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.0.7":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","version":"0.0.7","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.0.7","_engineSupported":false,"_npmVersion":"1.1.0-alpha-6","_nodeVersion":"v0.7.0-pre","_defaultsLoaded":true,"dist":{"shasum":"9ce3c76646435a243988a33f7ae4160cd1b3a020","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.0.7.tgz"},"maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.0.8":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","version":"0.0.8","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.0.8","_engineSupported":false,"_npmVersion":"1.1.0-alpha-6","_nodeVersion":"v0.7.0-pre","_defaultsLoaded":true,"dist":{"shasum":"baff08f6996b67b78af36850a4b5d341019a8e36","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.0.8.tgz"},"maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.0.9":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","version":"0.0.9","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.0.9","_engineSupported":false,"_npmVersion":"1.1.0-alpha-6","_nodeVersion":"v0.7.0-pre","_defaultsLoaded":true,"dist":{"shasum":"50909e12bd32fb3a7baf902b29e6c255addf6c30","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.0.9.tgz"},"maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.1.0":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","version":"0.1.0","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.1.0","_engineSupported":false,"_npmVersion":"1.1.0-alpha-6","_nodeVersion":"v0.7.0-pre","_defaultsLoaded":true,"dist":{"shasum":"795fb4af00298efa4b288ec81e8607802f41af41","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.1.0.tgz"},"maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.1.1":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","version":"0.1.1","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.1.1","_engineSupported":false,"_npmVersion":"1.1.0-beta-4","_nodeVersion":"v0.7.0-pre","_defaultsLoaded":true,"dist":{"shasum":"746f7cdb590b267a84d5114c8aa993b8a83c7959","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.1.1.tgz"},"readme":"# Harmony Collections Shim\n\nProvides Map, Set, and WeakMap with the same usage as the new ES6 native versions. Values in Harmony Collections are not contained in the collection instance itself, like array items and object properties, but in a private store. It's not possible to get access to or inspect the store directly.\n\nFor WeakMaps this means there's no way to find what's inside it or how many items are contained, and the only way to get a reference to a value is if you have a direct reference to the key object that links to it.\n\nWeakMap won't give the same garbage collector magic as the native one but it can be used with the same code.\n\n\n# Shim Usage\n\nThe function `attachIfMissing` is exported along with Map, WeakMap, and Set which will inspect the global object for the existence of Map, WeakMap, and Set in turn and add ones that are missing. Each one is checked separately because WeakMap's existence predates the other two so there's no guarantee which may already exist. If the global object is the window then `attach` is automatically executed.\n\n\n# Collections Usage\n\nMaps, WeakMaps, and Sets can each be created using their constructor with or without `new`. Examples:\n\n    var aWeakMap = new WeakMap;\n    var aMap = Map();\n    var aSet = new Set();\n\nItems in a collection do not appear in any manner through traditional inspection. The only way to interact with the data contained in a collection is by using the functions below.\n\n    var aWeakMap = new WeakMap;\n    aWeakMap.set(this, { secrets: 'Dark Secrets' });\n    console.log(Object.getOwnPropertyNames(aWeakMap)); // []\n    for (var k in aWeakMap) { console.log(k); }         // nothing\n    console.log(aWeakMap.get(this));                    // { secrets: 'Dark Secrets' }\n\n\n# WeakMap\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. Keys are per WeakMap are unique and setting the same key will overwrite the old value. WeakMaps provide for no method of iteration or listing the keys or values contained inside. Because WeakMaps expose no method of listing keys or values, and keys are required to be full-fledged objects with unique identities, the only way to extract a value from it is by having a direct reference to the object used as the key.\n\n* __set__ `weakmap.set(key, value)`. Key is any value including objects. Only non-primitives can be used as keys.\n* __get__ `weakmap.get(key)`. Returns the value that key corresponds to the key or undefined.\n* __has__ `weakmap.has(key)`. Returns boolean.\n* __delete__ `weakmap.delete(key)`. Removes value from the WeakMap if found. Returns true.\n\nWeakMaps allow for some interesting use cases like anonymous communication channels where neither side can identify the other, and no one else can eavesdrop. By using using a target object as its own key to retrieve a hidden seceret value no information about the origin can be obtained.\n\n*All non-primitives* are valid keys, including WeakMaps themselves.\n\n\n# Map\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `map.keys()`. Returns array of contained keys.\n* __values__ `map.values()`. Return array of contained values.\n* __iterate__ `map.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || null, key, value, index)`.\n\n*All possible values* are valid keys, including undefined, null, and NaN.\n\n\n# Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* __add__ `set.add(value)`. Inserts a value of any type into the set if it's not already in the set.\n* __has__ `set.has(value)`. Returns boolean.\n* __delete__ `set.delete(value)`. Removes value from the Set if found. Returns true.\n* __values__ `set.values()`. Return array of contained values.\n* __iterate__ `set.iterate(callback, context)`. Loop through the Set executing callback with the signature `callback.call(context || null, value, index)`.\n\n\n# TODO\n\n* Check up on iteration semantics for ES6 as they stand now.","maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.1.2":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","version":"0.1.2","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.1.2","_engineSupported":false,"_npmVersion":"1.1.0-beta-4","_nodeVersion":"v0.7.0-pre","_defaultsLoaded":true,"dist":{"shasum":"47573e1c93e89f958a5e51eafc03e3b1c056613d","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.1.2.tgz"},"readme":"# Harmony Collections Shim\n\nProvides Map, Set, and WeakMap with the same usage as the new ES6 native versions. Values in Harmony Collections are not contained in the collection instance itself, like array items and object properties, but in a private store. It's not possible to get access to or inspect the store directly.\n\nFor WeakMaps this means there's no way to find what's inside it or how many items are contained, and the only way to get a reference to a value is if you have a direct reference to the key object that links to it.\n\nWeakMap won't give the same garbage collector magic as the native one but it can be used with the same code.\n\n\n# Shim Usage\n\nThe function `attachIfMissing` is exported along with Map, WeakMap, and Set which will inspect the global object for the existence of Map, WeakMap, and Set in turn and add ones that are missing. Each one is checked separately because WeakMap's existence predates the other two so there's no guarantee which may already exist. If the global object is the window then `attach` is automatically executed.\n\n\n# Collections Usage\n\nMaps, WeakMaps, and Sets can each be created using their constructor with or without `new`. Examples:\n\n    var aWeakMap = new WeakMap;\n    var aMap = Map();\n    var aSet = new Set();\n\nItems in a collection do not appear in any manner through traditional inspection. The only way to interact with the data contained in a collection is by using the functions below.\n\n    var aWeakMap = new WeakMap;\n    aWeakMap.set(this, { secrets: 'Dark Secrets' });\n    console.log(Object.getOwnPropertyNames(aWeakMap)); // []\n    for (var k in aWeakMap) { console.log(k); }         // nothing\n    console.log(aWeakMap.get(this));                    // { secrets: 'Dark Secrets' }\n\n\n# WeakMap\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. Keys are per WeakMap are unique and setting the same key will overwrite the old value. WeakMaps provide for no method of iteration or listing the keys or values contained inside. Because WeakMaps expose no method of listing keys or values, and keys are required to be full-fledged objects with unique identities, the only way to extract a value from it is by having a direct reference to the object used as the key.\n\n* __set__ `weakmap.set(key, value)`. Key is any value including objects. Only non-primitives can be used as keys.\n* __get__ `weakmap.get(key)`. Returns the value that key corresponds to the key or undefined.\n* __has__ `weakmap.has(key)`. Returns boolean.\n* __delete__ `weakmap.delete(key)`. Removes value from the WeakMap if found. Returns true.\n\nWeakMaps allow for some interesting use cases like anonymous communication channels where neither side can identify the other, and no one else can eavesdrop. By using using a target object as its own key to retrieve a hidden seceret value no information about the origin can be obtained.\n\n*All non-primitives* are valid keys, including WeakMaps themselves.\n\n\n# Map\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `map.keys()`. Returns array of contained keys.\n* __values__ `map.values()`. Return array of contained values.\n* __iterate__ `map.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || null, key, value, index)`.\n\n*All possible values* are valid keys, including undefined, null, and NaN.\n\n\n# Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* __add__ `set.add(value)`. Inserts a value of any type into the set if it's not already in the set.\n* __has__ `set.has(value)`. Returns boolean.\n* __delete__ `set.delete(value)`. Removes value from the Set if found. Returns true.\n* __values__ `set.values()`. Return array of contained values.\n* __iterate__ `set.iterate(callback, context)`. Loop through the Set executing callback with the signature `callback.call(context || null, value, index)`.\n\n\n# TODO\n\n* Check up on iteration semantics for ES6 as they stand now.","maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.1.3":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","keywords":["harmony","collection","weakmap","map","set","ecmascript","shim"],"version":"0.1.3","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.1.3","_engineSupported":false,"_npmVersion":"1.1.0-beta-4","_nodeVersion":"v0.7.0-pre","_defaultsLoaded":true,"dist":{"shasum":"98ed483642d7a098f417c4f6b20c89f5c18b87a4","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.1.3.tgz"},"readme":"# Harmony Collections Shim\n\nProvides Map, Set, and WeakMap with the same usage as the new ES6 native versions. Values in Harmony Collections are not contained in the collection instance itself, like array items and object properties, but in a private store. It's not possible to get access to or inspect the store directly.\n\nFor WeakMaps this means there's no way to find what's inside it or how many items are contained, and the only way to get a reference to a value is if you have a direct reference to the key object that links to it.\n\nWeakMap won't give the same garbage collector magic as the native one but it can be used with the same code.\n\n\n# Shim Usage\n\nThe function `attachIfMissing` is exported along with Map, WeakMap, and Set which will inspect the global object for the existence of Map, WeakMap, and Set in turn and add ones that are missing. Each one is checked separately because WeakMap's existence predates the other two so there's no guarantee which may already exist. If the global object is the window then `attach` is automatically executed.\n\n\n# Collections Usage\n\nMaps, WeakMaps, and Sets can each be created using their constructor with or without `new`. Examples:\n\n    var aWeakMap = new WeakMap;\n    var aMap = Map();\n    var aSet = new Set();\n\nItems in a collection do not appear in any manner through traditional inspection. The only way to interact with the data contained in a collection is by using the functions below.\n\n    var aWeakMap = new WeakMap;\n    aWeakMap.set(this, { secrets: 'Dark Secrets' });\n    console.log(Object.getOwnPropertyNames(aWeakMap)); // []\n    for (var k in aWeakMap) { console.log(k); }         // nothing\n    console.log(aWeakMap.get(this));                    // { secrets: 'Dark Secrets' }\n\n\n# WeakMap\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. Keys are per WeakMap are unique and setting the same key will overwrite the old value. WeakMaps provide for no method of iteration or listing the keys or values contained inside. Because WeakMaps expose no method of listing keys or values, and keys are required to be full-fledged objects with unique identities, the only way to extract a value from it is by having a direct reference to the object used as the key.\n\n* __set__ `weakmap.set(key, value)`. Key is any value including objects. Only non-primitives can be used as keys.\n* __get__ `weakmap.get(key)`. Returns the value that key corresponds to the key or undefined.\n* __has__ `weakmap.has(key)`. Returns boolean.\n* __delete__ `weakmap.delete(key)`. Removes value from the WeakMap if found. Returns true.\n\nWeakMaps allow for some interesting use cases like anonymous communication channels where neither side can identify the other, and no one else can eavesdrop. By using using a target object as its own key to retrieve a hidden seceret value no information about the origin can be obtained.\n\n*All non-primitives* are valid keys, including WeakMaps themselves.\n\n\n# Map\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `map.keys()`. Returns array of contained keys.\n* __values__ `map.values()`. Return array of contained values.\n* __iterate__ `map.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || null, key, value, index)`.\n\n*All possible values* are valid keys, including undefined, null, and NaN.\n\n\n# Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* __add__ `set.add(value)`. Inserts a value of any type into the set if it's not already in the set.\n* __has__ `set.has(value)`. Returns boolean.\n* __delete__ `set.delete(value)`. Removes value from the Set if found. Returns true.\n* __values__ `set.values()`. Return array of contained values.\n* __iterate__ `set.iterate(callback, context)`. Loop through the Set executing callback with the signature `callback.call(context || null, value, index)`.\n\n\n# TODO\n\n* Check up on iteration semantics for ES6 as they stand now.","maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.1.4":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","keywords":["harmony","collection","weakmap","map","set","ecmascript","shim"],"version":"0.1.4","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.1.4","_engineSupported":false,"_npmVersion":"1.1.0-beta-4","_nodeVersion":"v0.7.0-pre","_defaultsLoaded":true,"dist":{"shasum":"10d54cd8229b647f6f7cf31490e86edb315b47f1","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.1.4.tgz"},"readme":"# Harmony Collections Shim\n\nProvides Map, Set, and WeakMap with the same usage as the new ES6 native versions. Values in Harmony Collections are not contained in the collection instance itself, like array items and object properties, but in a private store. It's not possible to get access to or inspect the store directly.\n\nFor WeakMaps this means there's no way to find what's inside it or how many items are contained, and the only way to get a reference to a value is if you have a direct reference to the key object that links to it.\n\nWeakMap won't give the same garbage collector magic as the native one but it can be used with the same code.\n\n\n# Shim Usage\n\nThe function `attachIfMissing` is exported along with Map, WeakMap, and Set which will inspect the global object for the existence of Map, WeakMap, and Set in turn and add ones that are missing. Each one is checked separately because WeakMap's existence predates the other two so there's no guarantee which may already exist. If the global object is the window then `attach` is automatically executed.\n\n\n# Collections Usage\n\nMaps, WeakMaps, and Sets can each be created using their constructor with or without `new`. Examples:\n\n    var aWeakMap = new WeakMap;\n    var aMap = Map();\n    var aSet = new Set();\n\nItems in a collection do not appear in any manner through traditional inspection. The only way to interact with the data contained in a collection is by using the functions below.\n\n    var aWeakMap = new WeakMap;\n    aWeakMap.set(this, { secrets: 'Dark Secrets' });\n    console.log(Object.getOwnPropertyNames(aWeakMap)); // []\n    for (var k in aWeakMap) { console.log(k); }         // nothing\n    console.log(aWeakMap.get(this));                    // { secrets: 'Dark Secrets' }\n\n\n# WeakMap\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. Keys are per WeakMap are unique and setting the same key will overwrite the old value. WeakMaps provide for no method of iteration or listing the keys or values contained inside. Because WeakMaps expose no method of listing keys or values, and keys are required to be full-fledged objects with unique identities, the only way to extract a value from it is by having a direct reference to the object used as the key.\n\n* __set__ `weakmap.set(key, value)`. Key is any value including objects. Only non-primitives can be used as keys.\n* __get__ `weakmap.get(key)`. Returns the value that key corresponds to the key or undefined.\n* __has__ `weakmap.has(key)`. Returns boolean.\n* __delete__ `weakmap.delete(key)`. Removes value from the WeakMap if found. Returns true.\n\nWeakMaps allow for some interesting use cases like anonymous communication channels where neither side can identify the other, and no one else can eavesdrop. By using using a target object as its own key to retrieve a hidden seceret value no information about the origin can be obtained.\n\n*All non-primitives* are valid keys, including WeakMaps themselves.\n\n\n# Map\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `map.keys()`. Returns array of contained keys.\n* __values__ `map.values()`. Return array of contained values.\n* __iterate__ `map.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || null, key, value, index)`.\n\n*All possible values* are valid keys, including undefined, null, and NaN.\n\n\n# Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* __add__ `set.add(value)`. Inserts a value of any type into the set if it's not already in the set.\n* __has__ `set.has(value)`. Returns boolean.\n* __delete__ `set.delete(value)`. Removes value from the Set if found. Returns true.\n* __values__ `set.values()`. Return array of contained values.\n* __iterate__ `set.iterate(callback, context)`. Loop through the Set executing callback with the signature `callback.call(context || null, value, index)`.\n\n\n# TODO\n\n* Check up on iteration semantics for ES6 as they stand now.","maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.1.5":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","keywords":["harmony","collection","weakmap","map","set","ecmascript","shim"],"version":"0.1.5","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.1.5","_engineSupported":false,"_npmVersion":"1.1.0-beta-4","_nodeVersion":"v0.7.0-pre","_defaultsLoaded":true,"dist":{"shasum":"01ef4705e2544fa204a1d69d8691cf4efc29a7b0","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.1.5.tgz"},"readme":"# Harmony Collections Shim\n\nProvides Map, Set, and WeakMap with the same usage as the new ES6 native versions. Values in Harmony Collections are not contained in the collection instance itself, like array items and object properties, but in a private store. It's not possible to get access to or inspect the store directly.\n\nFor WeakMaps this means there's no way to find what's inside it or how many items are contained, and the only way to get a reference to a value is if you have a direct reference to the key object that links to it.\n\nWeakMap won't give the same garbage collector magic as the native one but it can be used with the same code.\n\n\n# Shim Usage\n\nThe function `attachIfMissing` is exported along with Map, WeakMap, and Set which will inspect the global object for the existence of Map, WeakMap, and Set in turn and add ones that are missing. Each one is checked separately because WeakMap's existence predates the other two so there's no guarantee which may already exist. If the global object is the window then `attach` is automatically executed.\n\n\n# Collections Usage\n\nMaps, WeakMaps, and Sets can each be created using their constructor with or without `new`. Examples:\n\n    var aWeakMap = new WeakMap;\n    var aMap = Map();\n    var aSet = new Set();\n\nItems in a collection do not appear in any manner through traditional inspection. The only way to interact with the data contained in a collection is by using the functions below.\n\n    var aWeakMap = new WeakMap;\n    aWeakMap.set(this, { secrets: 'Dark Secrets' });\n    console.log(Object.getOwnPropertyNames(aWeakMap)); // []\n    for (var k in aWeakMap) { console.log(k); }         // nothing\n    console.log(aWeakMap.get(this));                    // { secrets: 'Dark Secrets' }\n\n\n# WeakMap\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. Keys are per WeakMap are unique and setting the same key will overwrite the old value. WeakMaps provide for no method of iteration or listing the keys or values contained inside. Because WeakMaps expose no method of listing keys or values, and keys are required to be full-fledged objects with unique identities, the only way to extract a value from it is by having a direct reference to the object used as the key.\n\n* __set__ `weakmap.set(key, value)`. Key is any value including objects. Only non-primitives can be used as keys.\n* __get__ `weakmap.get(key)`. Returns the value that key corresponds to the key or undefined.\n* __has__ `weakmap.has(key)`. Returns boolean.\n* __delete__ `weakmap.delete(key)`. Removes value from the WeakMap if found. Returns true.\n\nWeakMaps allow for some interesting use cases like anonymous communication channels where neither side can identify the other, and no one else can eavesdrop. By using using a target object as its own key to retrieve a hidden seceret value no information about the origin can be obtained.\n\n*All non-primitives* are valid keys, including WeakMaps themselves.\n\n\n# Map\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `map.keys()`. Returns array of contained keys.\n* __values__ `map.values()`. Return array of contained values.\n* __iterate__ `map.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || null, key, value, index)`.\n\n*All possible values* are valid keys, including undefined, null, and NaN.\n\n\n# Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* __add__ `set.add(value)`. Inserts a value of any type into the set if it's not already in the set.\n* __has__ `set.has(value)`. Returns boolean.\n* __delete__ `set.delete(value)`. Removes value from the Set if found. Returns true.\n* __values__ `set.values()`. Return array of contained values.\n* __iterate__ `set.iterate(callback, context)`. Loop through the Set executing callback with the signature `callback.call(context || null, value, index)`.\n\n\n# TODO\n\n* Check up on iteration semantics for ES6 as they stand now.","maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.1.6":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","keywords":["harmony","collection","weakmap","map","set","ecmascript","shim"],"version":"0.1.6","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.1.6","_engineSupported":false,"_npmVersion":"1.1.0-beta-4","_nodeVersion":"v0.7.0-pre","_defaultsLoaded":true,"dist":{"shasum":"0814b97378125f5fd8ed6f2fb6b160750180ca2c","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.1.6.tgz"},"readme":"# Harmony Collections Shim\n\nProvides Map, Set, and WeakMap with the same usage as the new ES6 native versions. Values in Harmony Collections are not contained in the collection instance itself, like array items and object properties, but in a private store. It's not possible to get access to or inspect the store directly.\n\nFor WeakMaps this means there's no way to find what's inside it or how many items are contained, and the only way to get a reference to a value is if you have a direct reference to the key object that links to it.\n\nWeakMap won't give the same garbage collector magic as the native one but it can be used with the same code.\n\n\n# Shim Usage\n\nThe function `attachIfMissing` is exported along with Map, WeakMap, and Set which will inspect the global object for the existence of Map, WeakMap, and Set in turn and add ones that are missing. Each one is checked separately because WeakMap's existence predates the other two so there's no guarantee which may already exist. If the global object is the window then `attach` is automatically executed.\n\n\n# Collections Usage\n\nMaps, WeakMaps, and Sets can each be created using their constructor with or without `new`. Examples:\n\n    var aWeakMap = new WeakMap;\n    var aMap = Map();\n    var aSet = new Set();\n\nItems in a collection do not appear in any manner through traditional inspection. The only way to interact with the data contained in a collection is by using the functions below.\n\n    var aWeakMap = new WeakMap;\n    aWeakMap.set(this, { secrets: 'Dark Secrets' });\n    console.log(Object.getOwnPropertyNames(aWeakMap)); // []\n    for (var k in aWeakMap) { console.log(k); }         // nothing\n    console.log(aWeakMap.get(this));                    // { secrets: 'Dark Secrets' }\n\n\n# WeakMap\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. Keys are per WeakMap are unique and setting the same key will overwrite the old value. WeakMaps provide for no method of iteration or listing the keys or values contained inside. Because WeakMaps expose no method of listing keys or values, and keys are required to be full-fledged objects with unique identities, the only way to extract a value from it is by having a direct reference to the object used as the key.\n\n* __set__ `weakmap.set(key, value)`. Key is any value including objects. Only non-primitives can be used as keys.\n* __get__ `weakmap.get(key)`. Returns the value that key corresponds to the key or undefined.\n* __has__ `weakmap.has(key)`. Returns boolean.\n* __delete__ `weakmap.delete(key)`. Removes value from the WeakMap if found. Returns true.\n\nWeakMaps allow for some interesting use cases like anonymous communication channels where neither side can identify the other, and no one else can eavesdrop. By using using a target object as its own key to retrieve a hidden seceret value no information about the origin can be obtained.\n\n*All non-primitives* are valid keys, including WeakMaps themselves.\n\n\n# Map\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `map.keys()`. Returns array of contained keys.\n* __values__ `map.values()`. Return array of contained values.\n* __iterate__ `map.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || null, key, value, index)`.\n\n*All possible values* are valid keys, including undefined, null, and NaN.\n\n\n# Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* __add__ `set.add(value)`. Inserts a value of any type into the set if it's not already in the set.\n* __has__ `set.has(value)`. Returns boolean.\n* __delete__ `set.delete(value)`. Removes value from the Set if found. Returns true.\n* __values__ `set.values()`. Return array of contained values.\n* __iterate__ `set.iterate(callback, context)`. Loop through the Set executing callback with the signature `callback.call(context || null, value, index)`.\n\n\n# TODO\n\n* Check up on iteration semantics for ES6 as they stand now.","maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.1.7":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","keywords":["harmony","collection","weakmap","map","set","ecmascript","shim"],"version":"0.1.7","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.1.7","_engineSupported":false,"_npmVersion":"1.1.0-beta-4","_nodeVersion":"v0.7.0-pre","_defaultsLoaded":true,"dist":{"shasum":"2b59551c1ca90c4b7de50d2d86cec54b5a2993cc","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.1.7.tgz"},"readme":"# Harmony Collections Shim\n\nProvides Map, Set, and WeakMap with the same usage as the new ES6 native versions. Values in Harmony Collections are not contained in the collection instance itself, like array items and object properties, but in a private store. It's not possible to get access to or inspect the store directly.\n\nFor WeakMaps this means there's no way to find what's inside it or how many items are contained, and the only way to get a reference to a value is if you have a direct reference to the key object that links to it.\n\nWeakMap won't give the same garbage collector magic as the native one but it can be used with the same code.\n\n\n# Shim Usage\n\nThe function `attachIfMissing` is exported along with Map, WeakMap, and Set which will inspect the global object for the existence of Map, WeakMap, and Set in turn and add ones that are missing. Each one is checked separately because WeakMap's existence predates the other two so there's no guarantee which may already exist. If the global object is the window then `attach` is automatically executed.\n\n\n# Collections Usage\n\nMaps, WeakMaps, and Sets can each be created using their constructor with or without `new`. Examples:\n\n    var aWeakMap = new WeakMap;\n    var aMap = Map();\n    var aSet = new Set();\n\nItems in a collection do not appear in any manner through traditional inspection. The only way to interact with the data contained in a collection is by using the functions below.\n\n    var aWeakMap = new WeakMap;\n    aWeakMap.set(this, { secrets: 'Dark Secrets' });\n    console.log(Object.getOwnPropertyNames(aWeakMap)); // []\n    for (var k in aWeakMap) { console.log(k); }         // nothing\n    console.log(aWeakMap.get(this));                    // { secrets: 'Dark Secrets' }\n\n\n# WeakMap\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. Keys are per WeakMap are unique and setting the same key will overwrite the old value. WeakMaps provide for no method of iteration or listing the keys or values contained inside. Because WeakMaps expose no method of listing keys or values, and keys are required to be full-fledged objects with unique identities, the only way to extract a value from it is by having a direct reference to the object used as the key.\n\n* __set__ `weakmap.set(key, value)`. Key is any value including objects. Only non-primitives can be used as keys.\n* __get__ `weakmap.get(key)`. Returns the value that key corresponds to the key or undefined.\n* __has__ `weakmap.has(key)`. Returns boolean.\n* __delete__ `weakmap.delete(key)`. Removes value from the WeakMap if found. Returns true.\n\nWeakMaps allow for some interesting use cases like anonymous communication channels where neither side can identify the other, and no one else can eavesdrop. By using using a target object as its own key to retrieve a hidden seceret value no information about the origin can be obtained.\n\n*All non-primitives* are valid keys, including WeakMaps themselves.\n\n\n# Map\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `map.keys()`. Returns array of contained keys.\n* __values__ `map.values()`. Return array of contained values.\n* __iterate__ `map.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || null, key, value, index)`.\n\n*All possible values* are valid keys, including undefined, null, and NaN.\n\n\n# Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* __add__ `set.add(value)`. Inserts a value of any type into the set if it's not already in the set.\n* __has__ `set.has(value)`. Returns boolean.\n* __delete__ `set.delete(value)`. Removes value from the Set if found. Returns true.\n* __values__ `set.values()`. Return array of contained values.\n* __iterate__ `set.iterate(callback, context)`. Loop through the Set executing callback with the signature `callback.call(context || null, value, index)`.\n\n\n# TODO\n\n* Check up on iteration semantics for ES6 as they stand now.","maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.1.8":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","keywords":["harmony","collection","weakmap","map","set","ecmascript","shim"],"version":"0.1.8","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.1.8","_engineSupported":false,"_npmVersion":"1.1.0-beta-4","_nodeVersion":"v0.7.0-pre","_defaultsLoaded":true,"dist":{"shasum":"9e1d85d40114ab82b499458fade39bb56611d404","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.1.8.tgz"},"readme":"# Harmony Collections Shim\n\nProvides Map, Set, and WeakMap with the same usage as the new ES6 native versions. Values in Harmony Collections are not contained in the collection instance itself, like array items and object properties, but in a private store. It's not possible to get access to or inspect the store directly.\n\nFor WeakMaps this means there's no way to find what's inside it or how many items are contained, and the only way to get a reference to a value is if you have a direct reference to the key object that links to it.\n\nWeakMap won't give the same garbage collector magic as the native one but it can be used with the same code.\n\n\n# Shim Usage\n\nThe function `attachIfMissing` is exported along with Map, WeakMap, and Set which will inspect the global object for the existence of Map, WeakMap, and Set in turn and add ones that are missing. Each one is checked separately because WeakMap's existence predates the other two so there's no guarantee which may already exist. If the global object is the window then `attach` is automatically executed.\n\n\n# Collections Usage\n\nMaps, WeakMaps, and Sets can each be created using their constructor with or without `new`. Examples:\n\n    var aWeakMap = new WeakMap;\n    var aMap = Map();\n    var aSet = new Set();\n\nItems in a collection do not appear in any manner through traditional inspection. The only way to interact with the data contained in a collection is by using the functions below.\n\n    var aWeakMap = new WeakMap;\n    aWeakMap.set(this, { secrets: 'Dark Secrets' });\n    console.log(Object.getOwnPropertyNames(aWeakMap)); // []\n    for (var k in aWeakMap) { console.log(k); }         // nothing\n    console.log(aWeakMap.get(this));                    // { secrets: 'Dark Secrets' }\n\n\n# WeakMap\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. Keys are per WeakMap are unique and setting the same key will overwrite the old value. WeakMaps provide for no method of iteration or listing the keys or values contained inside. Because WeakMaps expose no method of listing keys or values, and keys are required to be full-fledged objects with unique identities, the only way to extract a value from it is by having a direct reference to the object used as the key.\n\n* __set__ `weakmap.set(key, value)`. Key is any value including objects. Only non-primitives can be used as keys.\n* __get__ `weakmap.get(key)`. Returns the value that key corresponds to the key or undefined.\n* __has__ `weakmap.has(key)`. Returns boolean.\n* __delete__ `weakmap.delete(key)`. Removes value from the WeakMap if found. Returns true.\n\nWeakMaps allow for some interesting use cases like anonymous communication channels where neither side can identify the other, and no one else can eavesdrop. By using using a target object as its own key to retrieve a hidden seceret value no information about the origin can be obtained.\n\n*All non-primitives* are valid keys, including WeakMaps themselves.\n\n\n# Map\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `map.keys()`. Returns array of contained keys.\n* __values__ `map.values()`. Return array of contained values.\n* __iterate__ `map.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || null, key, value, index)`.\n\n*All possible values* are valid keys, including undefined, null, and NaN.\n\n\n# Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* __add__ `set.add(value)`. Inserts a value of any type into the set if it's not already in the set.\n* __has__ `set.has(value)`. Returns boolean.\n* __delete__ `set.delete(value)`. Removes value from the Set if found. Returns true.\n* __values__ `set.values()`. Return array of contained values.\n* __iterate__ `set.iterate(callback, context)`. Loop through the Set executing callback with the signature `callback.call(context || null, value, index)`.\n\n\n# TODO\n\n* Check up on iteration semantics for ES6 as they stand now.","maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.2.0":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","keywords":["harmony","collection","weakmap","map","set","ecmascript","shim"],"version":"0.2.0","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.2.0","_engineSupported":false,"_npmVersion":"1.1.0-beta-4","_nodeVersion":"v0.7.0-pre","_defaultsLoaded":true,"dist":{"shasum":"fdde131fc82d20c23317298bb82cfbbc661ac4a4","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.2.0.tgz"},"readme":"# Harmony Collections Shim\n\nProvides Map, Set, and WeakMap with the same usage as the new ES6 native versions. Values in Harmony Collections are not contained in the collection instance itself, like array items and object properties, but in a private store. It's not possible to get access to or inspect the store directly.\n\nFor WeakMaps this means there's no way to find what's inside it or how many items are contained, and the only way to get a reference to a value is if you have a direct reference to the key object that links to it.\n\nWeakMap won't give the same garbage collector magic as the native one but it can be used with the same code.\n\n\n# Shim Usage\n\nThe function `attachIfMissing` is exported along with Map, WeakMap, and Set which will inspect the global object for the existence of Map, WeakMap, and Set in turn and add ones that are missing. Each one is checked separately because WeakMap's existence predates the other two so there's no guarantee which may already exist. If the global object is the window then `attach` is automatically executed.\n\n\n# Collections Usage\n\nMaps, WeakMaps, and Sets can each be created using their constructor with or without `new`. Examples:\n\n    var aWeakMap = new WeakMap;\n    var aMap = Map();\n    var aSet = new Set();\n\nItems in a collection do not appear in any manner through traditional inspection. The only way to interact with the data contained in a collection is by using the functions below.\n\n    var aWeakMap = new WeakMap;\n    aWeakMap.set(this, { secrets: 'Dark Secrets' });\n    console.log(Object.getOwnPropertyNames(aWeakMap)); // []\n    for (var k in aWeakMap) { console.log(k); }         // nothing\n    console.log(aWeakMap.get(this));                    // { secrets: 'Dark Secrets' }\n\n\n# WeakMap\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. Keys are per WeakMap are unique and setting the same key will overwrite the old value. WeakMaps provide for no method of iteration or listing the keys or values contained inside. Because WeakMaps expose no method of listing keys or values, and keys are required to be full-fledged objects with unique identities, the only way to extract a value from it is by having a direct reference to the object used as the key.\n\n* __set__ `weakmap.set(key, value)`. Key is any value including objects. Only non-primitives can be used as keys.\n* __get__ `weakmap.get(key)`. Returns the value that key corresponds to the key or undefined.\n* __has__ `weakmap.has(key)`. Returns boolean.\n* __delete__ `weakmap.delete(key)`. Removes value from the WeakMap if found. Returns true.\n\nWeakMaps allow for some interesting use cases like anonymous communication channels where neither side can identify the other, and no one else can eavesdrop. By using using a target object as its own key to retrieve a hidden seceret value no information about the origin can be obtained.\n\n*All non-primitives* are valid keys, including WeakMaps themselves.\n\n\n# Map\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `map.keys()`. Returns array of contained keys.\n* __values__ `map.values()`. Return array of contained values.\n* __iterate__ `map.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || null, key, value, index)`.\n\n*All possible values* are valid keys, including undefined, null, and NaN.\n\n\n# Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* __add__ `set.add(value)`. Inserts a value of any type into the set if it's not already in the set.\n* __has__ `set.has(value)`. Returns boolean.\n* __delete__ `set.delete(value)`. Removes value from the Set if found. Returns true.\n* __values__ `set.values()`. Return array of contained values.\n* __iterate__ `set.iterate(callback, context)`. Loop through the Set executing callback with the signature `callback.call(context || null, value, index)`.\n\n\n# TODO\n\n* Check up on iteration semantics for ES6 as they stand now.","maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.2.1":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","keywords":["harmony","collection","weakmap","map","set","ecmascript","shim"],"version":"0.2.1","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.2.1","optionalDependencies":{},"_engineSupported":false,"_npmVersion":"1.1.15","_nodeVersion":"v0.7.8","_defaultsLoaded":true,"dist":{"shasum":"d16bc516ec21f82f805944994c8bf22c8d5a8ea5","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.2.1.tgz"},"readme":"# Harmony Collections Shim\n\nProvides Map, Set, and WeakMap with the same usage as the new ES6 native versions. Values in Harmony Collections are not contained in the collection instance itself, like array items and object properties, but in a private store. It's not possible to get access to or inspect the store directly.\n\nFor WeakMaps this means there's no way to find what's inside it or how many items are contained, and the only way to get a reference to a value is if you have a direct reference to the key object that links to it.\n\nWeakMap garbage collection functionality isn't quite to spec. Keys hold references to their values strongly which has the potential cause certain types of usage to disallow garbage collection of values in the group. However, even this is still better than any other gc scheme that can be implemented in JS.\n\n\n# Collections Usage\n\nMaps, WeakMaps, Hashes, and Sets can each be created using their constructor with or without `new`. Examples:\n\n    var aWeakMap = new WeakMap;\n    var aMap = Map();\n    var aSet = new Set();\n\nItems in a collection do not appear in any manner through traditional inspection. The only way to interact with the data contained in a collection is by using the functions below.\n\n    var aWeakMap = new WeakMap;\n    aWeakMap.set(this, { secrets: 'Dark Secrets' });\n    console.log(Object.getOwnPropertyNames(aWeakMap)); // []\n    for (var k in aWeakMap) { console.log(k); }         // nothing\n    console.log(aWeakMap.get(this));                    // { secrets: 'Dark Secrets' }\n\n\n# WeakMap\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. Keys are per WeakMap are unique and setting the same key will overwrite the old value. WeakMaps provide for no method of iteration or listing the keys or values contained inside. Because WeakMaps expose no method of listing keys or values, and keys are required to be full-fledged objects with unique identities, the only way to extract a value from it is by having a direct reference to the object used as the key.\n\n* __set__ `weakmap.set(key, value)`. Key is any value including objects. Only non-primitives can be used as keys.\n* __get__ `weakmap.get(key)`. Returns the value that key corresponds to the key or undefined.\n* __has__ `weakmap.has(key)`. Returns boolean.\n* __delete__ `weakmap.delete(key)`. Removes value from the WeakMap if found. Returns true.\n\nWeakMaps allow for some interesting use cases like anonymous communication channels where neither side can identify the other, and no one else can eavesdrop. By using using a target object as its own key to retrieve a hidden seceret value no information about the origin can be obtained.\n\n__All non-primitives__ are valid keys, including WeakMaps themselves.\n\n\n# Map\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `map.keys()`. Returns array of contained keys.\n* __values__ `map.values()`. Return array of contained values.\n* __iterate__ `map.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || null, key, value, index)`.\n\n__All possible values__ are valid keys, including undefined, null, and NaN.\n\n\n# Hash\n\nAs an added bonus, Hash is also exported. This has the same API as a Map except it only accepts primitive keys.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `map.keys()`. Returns array of contained keys.\n* __values__ `map.values()`. Return array of contained values.\n* __iterate__ `map.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || null, key, value, index)`.\n\n__Primitives__ are valid keys, specifically numbers and strings. All input values are coerced to strings so you can give it any value, but they will be converted to string keys.\n\n\n# Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* __add__ `set.add(value)`. Inserts a value of any type into the set if it's not already in the set.\n* __has__ `set.has(value)`. Returns boolean.\n* __delete__ `set.delete(value)`. Removes value from the Set if found. Returns true.\n* __values__ `set.values()`. Return array of contained values.\n* __iterate__ `set.iterate(callback, context)`. Loop through the Set executing callback with the signature `callback.call(context || null, value, index)`.","maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.2.2":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","keywords":["harmony","collection","weakmap","map","set","ecmascript","shim"],"version":"0.2.2","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.2.2","optionalDependencies":{},"_engineSupported":false,"_npmVersion":"1.1.15","_nodeVersion":"v0.7.8","_defaultsLoaded":true,"dist":{"shasum":"9914c9d564e1a121fce6731257f71522f3954f8b","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.2.2.tgz"},"readme":"# Harmony Collections Shim\n\nProvides Map, Set, and WeakMap with the same usage as the new ES6 native versions. Values in Harmony Collections are not contained in the collection instance itself, like array items and object properties, but in a private store. It's not possible to get access to or inspect the store directly.\n\nFor WeakMaps this means there's no way to find what's inside it or how many items are contained, and the only way to get a reference to a value is if you have a direct reference to the key object that links to it.\n\nWeakMap garbage collection functionality isn't quite to spec. Keys hold references to their values strongly which has the potential cause certain types of usage to disallow garbage collection of values in the group. However, even this is still better than any other gc scheme that can be implemented in JS.\n\n\n# Collections Usage\n\nMaps, WeakMaps, Hashes, and Sets can each be created using their constructor with or without `new`. Examples:\n\n    var aWeakMap = new WeakMap;\n    var aMap = Map();\n    var aSet = new Set();\n\nItems in a collection do not appear in any manner through traditional inspection. The only way to interact with the data contained in a collection is by using the functions below.\n\n    var aWeakMap = new WeakMap;\n    aWeakMap.set(this, { secrets: 'Dark Secrets' });\n    console.log(Object.getOwnPropertyNames(aWeakMap)); // []\n    for (var k in aWeakMap) { console.log(k); }         // nothing\n    console.log(aWeakMap.get(this));                    // { secrets: 'Dark Secrets' }\n\n\n# WeakMap\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. Keys are per WeakMap are unique and setting the same key will overwrite the old value. WeakMaps provide for no method of iteration or listing the keys or values contained inside. Because WeakMaps expose no method of listing keys or values, and keys are required to be full-fledged objects with unique identities, the only way to extract a value from it is by having a direct reference to the object used as the key.\n\n* __set__ `weakmap.set(key, value)`. Key is any value including objects. Only non-primitives can be used as keys.\n* __get__ `weakmap.get(key)`. Returns the value that key corresponds to the key or undefined.\n* __has__ `weakmap.has(key)`. Returns boolean.\n* __delete__ `weakmap.delete(key)`. Removes value from the WeakMap if found. Returns true.\n\nWeakMaps allow for some interesting use cases like anonymous communication channels where neither side can identify the other, and no one else can eavesdrop. By using using a target object as its own key to retrieve a hidden seceret value no information about the origin can be obtained.\n\n__All non-primitives__ are valid keys, including WeakMaps themselves.\n\n\n# Map\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `map.keys()`. Returns array of contained keys.\n* __values__ `map.values()`. Return array of contained values.\n* __iterate__ `map.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || null, key, value, index)`.\n\n__All possible values__ are valid keys, including undefined, null, and NaN.\n\n\n# Hash\n\nAs an added bonus, Hash is also exported. This has the same API as a Map except it only accepts primitive keys.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `map.keys()`. Returns array of contained keys.\n* __values__ `map.values()`. Return array of contained values.\n* __iterate__ `map.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || null, key, value, index)`.\n\n__Primitives__ are valid keys, specifically numbers and strings. All input values are coerced to strings so you can give it any value, but they will be converted to string keys.\n\n\n# Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* __add__ `set.add(value)`. Inserts a value of any type into the set if it's not already in the set.\n* __has__ `set.has(value)`. Returns boolean.\n* __delete__ `set.delete(value)`. Removes value from the Set if found. Returns true.\n* __values__ `set.values()`. Return array of contained values.\n* __iterate__ `set.iterate(callback, context)`. Loop through the Set executing callback with the signature `callback.call(context || null, value, index)`.","maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.2.3":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","keywords":["harmony","collection","weakmap","map","set","ecmascript","shim"],"version":"0.2.3","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.2.3","optionalDependencies":{},"_engineSupported":false,"_npmVersion":"1.1.15","_nodeVersion":"v0.7.8","_defaultsLoaded":true,"dist":{"shasum":"2ca1c2cddd46b39c8bdc01ad8f706e4ad89ecf2c","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.2.3.tgz"},"readme":"# Harmony Collections Shim\n\nProvides Map, Set, and WeakMap with the same usage as the new ES6 native versions. Values in Harmony Collections are not contained in the collection instance itself, like array items and object properties, but in a private store. It's not possible to get access to or inspect the store directly.\n\nFor WeakMaps this means there's no way to find what's inside it or how many items are contained, and the only way to get a reference to a value is if you have a direct reference to the key object that links to it.\n\nWeakMap garbage collection functionality isn't quite to spec. Keys hold references to their values strongly which has the potential cause certain types of usage to disallow garbage collection of values in the group. However, even this is still better than any other gc scheme that can be implemented in JS.\n\n\n# Collections Usage\n\nMaps, WeakMaps, Hashes, and Sets can each be created using their constructor with or without `new`. Examples:\n\n    var aWeakMap = new WeakMap;\n    var aMap = Map();\n    var aSet = new Set();\n\nItems in a collection do not appear in any manner through traditional inspection. The only way to interact with the data contained in a collection is by using the functions below.\n\n    var aWeakMap = new WeakMap;\n    aWeakMap.set(this, { secrets: 'Dark Secrets' });\n    console.log(Object.getOwnPropertyNames(aWeakMap)); // []\n    for (var k in aWeakMap) { console.log(k); }         // nothing\n    console.log(aWeakMap.get(this));                    // { secrets: 'Dark Secrets' }\n\n\n# WeakMap\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. Keys are per WeakMap are unique and setting the same key will overwrite the old value. WeakMaps provide for no method of iteration or listing the keys or values contained inside. Because WeakMaps expose no method of listing keys or values, and keys are required to be full-fledged objects with unique identities, the only way to extract a value from it is by having a direct reference to the object used as the key.\n\n* __set__ `weakmap.set(key, value)`. Key is any value including objects. Only non-primitives can be used as keys.\n* __get__ `weakmap.get(key)`. Returns the value that key corresponds to the key or undefined.\n* __has__ `weakmap.has(key)`. Returns boolean.\n* __delete__ `weakmap.delete(key)`. Removes value from the WeakMap if found. Returns true.\n\nWeakMaps allow for some interesting use cases like anonymous communication channels where neither side can identify the other, and no one else can eavesdrop. By using using a target object as its own key to retrieve a hidden seceret value no information about the origin can be obtained.\n\n__All non-primitives__ are valid keys, including WeakMaps themselves.\n\n\n# Map\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `map.keys()`. Returns array of contained keys.\n* __values__ `map.values()`. Return array of contained values.\n* __iterate__ `map.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || null, key, value, index)`.\n\n__All possible values__ are valid keys, including undefined, null, and NaN.\n\n\n# Hash\n\nAs an added bonus, Hash is also exported. This has the same API as a Map except it only accepts primitive keys.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `map.keys()`. Returns array of contained keys.\n* __values__ `map.values()`. Return array of contained values.\n* __iterate__ `map.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || null, key, value, index)`.\n\n__Primitives__ are valid keys, specifically numbers and strings. All input values are coerced to strings so you can give it any value, but they will be converted to string keys.\n\n\n# Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* __add__ `set.add(value)`. Inserts a value of any type into the set if it's not already in the set.\n* __has__ `set.has(value)`. Returns boolean.\n* __delete__ `set.delete(value)`. Removes value from the Set if found. Returns true.\n* __values__ `set.values()`. Return array of contained values.\n* __iterate__ `set.iterate(callback, context)`. Loop through the Set executing callback with the signature `callback.call(context || null, value, index)`.","maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.2.4":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available","keywords":["harmony","collection","weakmap","map","set","ecmascript","shim"],"version":"0.2.4","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.2.4","optionalDependencies":{},"_engineSupported":false,"_npmVersion":"1.1.15","_nodeVersion":"v0.7.8","_defaultsLoaded":true,"dist":{"shasum":"0574965d15a3557a5b3c421a4d9b13a7a2a2a6b3","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.2.4.tgz"},"readme":"# Harmony Collections Shim\n\nProvides Map, Set, and WeakMap with the same usage as the new ES6 native versions. Values in Harmony Collections are not contained in the collection instance itself, like array items and object properties, but in a private store. It's not possible to get access to or inspect the store directly.\n\nFor WeakMaps this means there's no way to find what's inside it or how many items are contained, and the only way to get a reference to a value is if you have a direct reference to the key object that links to it.\n\nWeakMap garbage collection functionality isn't quite to spec. Keys hold references to their values strongly which has the potential cause certain types of usage to disallow garbage collection of values in the group. However, even this is still better than any other gc scheme that can be implemented in JS.\n\n\n# Collections Usage\n\nMaps, WeakMaps, Hashes, and Sets can each be created using their constructor with or without `new`. Examples:\n\n    var aWeakMap = new WeakMap;\n    var aMap = Map();\n    var aSet = new Set();\n\nItems in a collection do not appear in any manner through traditional inspection. The only way to interact with the data contained in a collection is by using the functions below.\n\n    var aWeakMap = new WeakMap;\n    aWeakMap.set(this, { secrets: 'Dark Secrets' });\n    console.log(Object.getOwnPropertyNames(aWeakMap)); // []\n    for (var k in aWeakMap) { console.log(k); }         // nothing\n    console.log(aWeakMap.get(this));                    // { secrets: 'Dark Secrets' }\n\n\n# WeakMap\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. Keys are per WeakMap are unique and setting the same key will overwrite the old value. WeakMaps provide for no method of iteration or listing the keys or values contained inside. Because WeakMaps expose no method of listing keys or values, and keys are required to be full-fledged objects with unique identities, the only way to extract a value from it is by having a direct reference to the object used as the key.\n\n* __set__ `weakmap.set(key, value)`. Key is any value including objects. Only non-primitives can be used as keys.\n* __get__ `weakmap.get(key)`. Returns the value that key corresponds to the key or undefined.\n* __has__ `weakmap.has(key)`. Returns boolean.\n* __delete__ `weakmap.delete(key)`. Removes value from the WeakMap if found. Returns true.\n\nWeakMaps allow for some interesting use cases like anonymous communication channels where neither side can identify the other, and no one else can eavesdrop. By using using a target object as its own key to retrieve a hidden seceret value no information about the origin can be obtained.\n\n__All non-primitives__ are valid keys, including WeakMaps themselves.\n\n\n# Map\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `map.keys()`. Returns array of contained keys.\n* __values__ `map.values()`. Return array of contained values.\n* __iterate__ `map.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || global, value, key)`.\n* __toArray__ `map.toArray()`. Return array of Pair objects of the form `{ key: KEY, value: VALUE }`.\n\n__All possible values__ are valid keys, including undefined, null, and NaN.\n\n\n# Hash\n\nAs an added bonus, Hash is also exported. This has the same API as a Map except it only accepts primitive keys.\n\n* __set__ `hash.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `hash.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `hash.has(key)`. Returns boolean.\n* __delete__ `hash.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `hash.keys()`. Returns array of contained keys.\n* __values__ `hash.values()`. Return array of contained values.\n* __iterate__ `hash.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || global, value, key)`.\n* __toArray__ `hash.values()`. Return array of Pair objects of the form `{ key: KEY, value: VALUE }`.\n* __toObject__ `hash.toArray()`. Returns a plain object with the keys and values.\n\n__Primitives__ are valid keys, specifically numbers and strings. All input values are coerced to strings so you can give it any value, but they will be converted to string keys.\n\n\n# Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* __add__ `set.add(value)`. Inserts a value of any type into the set if it's not already in the set.\n* __has__ `set.has(value)`. Returns boolean.\n* __delete__ `set.delete(value)`. Removes value from the Set if found. Returns true.\n* __values__ `set.values()`. Return array of contained values.\n* __iterate__ `set.iterate(callback, context)`. Loop through the Set executing callback with the signature `callback.call(context || global, value, index)`.","maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.2.5":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available, with non-leaky O(1) lookup WeakMaps","keywords":["harmony","collection","weakmap","map","set","ecmascript","shim","garbage collection"],"version":"0.2.5","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{"tap":"*"},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.2.5","optionalDependencies":{},"_engineSupported":false,"_npmVersion":"1.1.18","_nodeVersion":"v0.7.8","_defaultsLoaded":true,"dist":{"shasum":"45e16715db25a8aeaf9feb58ccdc242210a92adb","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.2.5.tgz"},"readme":"# Harmony Collections Shim\n\nProvides Map, Set, and WeakMap with the same usage as the new ES6 native versions. Values in Harmony Collections are not contained in the collection instance itself, like array items and object properties, but in a private store. It's not possible to get access to or inspect the store directly.\n\nFor WeakMaps this means there's no way to find what's inside it or how many items are contained, and the only way to get a reference to a value is if you have a direct reference to the key object that links to it.\n\nWeakMap garbage collection functionality isn't quite to spec. Keys hold references to their values strongly which has the potential cause certain types of usage to disallow garbage collection of values in the group. However, even this is still better than any other gc scheme that can be implemented in JS.\n\n\n# Collections Usage\n\nMaps, WeakMaps, Hashes, and Sets can each be created using their constructor with or without `new`. Examples:\n\n    var aWeakMap = new WeakMap;\n    var aMap = Map();\n    var aSet = new Set();\n\nItems in a collection do not appear in any manner through traditional inspection. The only way to interact with the data contained in a collection is by using the functions below.\n\n    var aWeakMap = new WeakMap;\n    aWeakMap.set(this, { secrets: 'Dark Secrets' });\n    console.log(Object.getOwnPropertyNames(aWeakMap)); // []\n    for (var k in aWeakMap) { console.log(k); }         // nothing\n    console.log(aWeakMap.get(this));                    // { secrets: 'Dark Secrets' }\n\n\n# WeakMap\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. Keys are per WeakMap are unique and setting the same key will overwrite the old value. WeakMaps provide for no method of iteration or listing the keys or values contained inside. Because WeakMaps expose no method of listing keys or values, and keys are required to be full-fledged objects with unique identities, the only way to extract a value from it is by having a direct reference to the object used as the key.\n\n* __set__ `weakmap.set(key, value)`. Key is any value including objects. Only non-primitives can be used as keys.\n* __get__ `weakmap.get(key)`. Returns the value that key corresponds to the key or undefined.\n* __has__ `weakmap.has(key)`. Returns boolean.\n* __delete__ `weakmap.delete(key)`. Removes value from the WeakMap if found. Returns true.\n\nWeakMaps allow for some interesting use cases like anonymous communication channels where neither side can identify the other, and no one else can eavesdrop. By using using a target object as its own key to retrieve a hidden seceret value no information about the origin can be obtained.\n\n__All non-primitives__ are valid keys, including WeakMaps themselves.\n\n\n# Map\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `map.keys()`. Returns array of contained keys.\n* __values__ `map.values()`. Return array of contained values.\n* __iterate__ `map.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || global, value, key)`.\n* __toArray__ `map.toArray()`. Return array of Pair objects of the form `{ key: KEY, value: VALUE }`.\n\n__All possible values__ are valid keys, including undefined, null, and NaN.\n\n\n# Hash\n\nAs an added bonus, Hash is also exported. This has the same API as a Map except it only accepts primitive keys.\n\n* __set__ `hash.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `hash.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `hash.has(key)`. Returns boolean.\n* __delete__ `hash.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `hash.keys()`. Returns array of contained keys.\n* __values__ `hash.values()`. Return array of contained values.\n* __iterate__ `hash.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || global, value, key)`.\n* __toArray__ `hash.values()`. Return array of Pair objects of the form `{ key: KEY, value: VALUE }`.\n* __toObject__ `hash.toArray()`. Returns a plain object with the keys and values.\n\n__Primitives__ are valid keys, specifically numbers and strings. All input values are coerced to strings so you can give it any value, but they will be converted to string keys.\n\n\n# Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* __add__ `set.add(value)`. Inserts a value of any type into the set if it's not already in the set.\n* __has__ `set.has(value)`. Returns boolean.\n* __delete__ `set.delete(value)`. Removes value from the Set if found. Returns true.\n* __values__ `set.values()`. Return array of contained values.\n* __iterate__ `set.iterate(callback, context)`. Loop through the Set executing callback with the signature `callback.call(context || global, value, index)`.","maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.2.6":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available, with non-leaky O(1) lookup WeakMaps","keywords":["harmony","collection","weakmap","map","set","ecmascript","shim","garbage collection"],"version":"0.2.6","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"git://github.com/Benvie/ES6-Harmony-Collections-Shim.git"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{"tap":"*"},"_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"_id":"harmony-collections@0.2.6","optionalDependencies":{},"_engineSupported":false,"_npmVersion":"1.1.18","_nodeVersion":"v0.7.8","_defaultsLoaded":true,"dist":{"shasum":"1a9e4b96ee496dd5f5d0e2395bf21915f6d29831","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.2.6.tgz"},"readme":"# Harmony Collections Shim\n\nProvides Map, Set, and WeakMap with the same usage as the new ES6 native versions. Values in Harmony Collections are not contained in the collection instance itself, like array items and object properties, but in a private store. It's not possible to get access to or inspect the store directly.\n\nFor WeakMaps this means there's no way to find what's inside it or how many items are contained, and the only way to get a reference to a value is if you have a direct reference to the key object that links to it.\n\n# Compatability\n\nWorks with IE9+, Chrome, Firefox, Safari, untested in Opera.\n\n# Collections Usage\n\nMaps, WeakMaps, Hashes, and Sets can each be created using their constructor with or without `new`. Examples:\n\n    var aWeakMap = new WeakMap;\n    var aMap = Map();\n    var aSet = new Set();\n\nItems in a collection do not appear in any manner through traditional inspection. The only way to interact with the data contained in a collection is by using the functions below.\n\n    var aWeakMap = new WeakMap;\n    aWeakMap.set(this, { secrets: 'Dark Secrets' });\n    console.log(Object.getOwnPropertyNames(aWeakMap)); // []\n    for (var k in aWeakMap) { console.log(k); }         // nothing\n    console.log(aWeakMap.get(this));                    // { secrets: 'Dark Secrets' }\n\n\n# WeakMap\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. Keys are per WeakMap are unique and setting the same key will overwrite the old value. WeakMaps provide for no method of iteration or listing the keys or values contained inside. Because WeakMaps expose no method of listing keys or values, and keys are required to be full-fledged objects with unique identities, the only way to extract a value from it is by having a direct reference to the object used as the key.\n\n* __set__ `weakmap.set(key, value)`. Key is any value including objects. Only non-primitives can be used as keys.\n* __get__ `weakmap.get(key)`. Returns the value that key corresponds to the key or undefined.\n* __has__ `weakmap.has(key)`. Returns boolean.\n* __delete__ `weakmap.delete(key)`. Removes value from the WeakMap if found. Returns true.\n\nWeakMaps allow for some interesting use cases like anonymous communication channels where neither side can identify the other, and no one else can eavesdrop. By using using a target object as its own key to retrieve a hidden seceret value no information about the origin can be obtained.\n\n__All non-primitives__ are valid keys, including WeakMaps themselves.\n\n\n# Map\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `map.keys()`. Returns array of contained keys.\n* __values__ `map.values()`. Return array of contained values.\n* __iterate__ `map.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || global, value, key)`.\n* __toArray__ `map.toArray()`. Return array of Pair objects of the form `{ key: KEY, value: VALUE }`.\n\n__All possible values__ are valid keys, including undefined, null, and NaN.\n\n\n# Hash\n\nAs an added bonus, Hash is also exported. This has the same API as a Map except it only accepts primitive keys.\n\n* __set__ `hash.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `hash.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `hash.has(key)`. Returns boolean.\n* __delete__ `hash.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `hash.keys()`. Returns array of contained keys.\n* __values__ `hash.values()`. Return array of contained values.\n* __iterate__ `hash.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || global, value, key)`.\n* __toArray__ `hash.values()`. Return array of Pair objects of the form `{ key: KEY, value: VALUE }`.\n* __toObject__ `hash.toArray()`. Returns a plain object with the keys and values.\n\n__Primitives__ are valid keys, specifically numbers and strings. All input values are coerced to strings so you can give it any value, but they will be converted to string keys.\n\n\n# Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* __add__ `set.add(value)`. Inserts a value of any type into the set if it's not already in the set.\n* __has__ `set.has(value)`. Returns boolean.\n* __delete__ `set.delete(value)`. Removes value from the Set if found. Returns true.\n* __values__ `set.values()`. Return array of contained values.\n* __iterate__ `set.iterate(callback, context)`. Loop through the Set executing callback with the signature `callback.call(context || global, value, index)`.","maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.2.9":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Provides Map, Set, and WeakMap with the same usage as the new ES6 native versions. Values in Harmony Collections are not contained in the collection instance itself, like array items and object properties, but in a private store. It's not possible to get access to or inspect the store directly.","keywords":["harmony","collection","weakmap","map","set","ecmascript","shim","garbage collection"],"version":"0.2.9","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"https://github.com/Benvie/ES6-Harmony-Collections-Shim"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{"tap":"*"},"readme":"# Harmony Collections Shim\n\nProvides Map, Set, and WeakMap with the same usage as the new ES6 native versions. Values in Harmony Collections are not contained in the collection instance itself, like array items and object properties, but in a private store. It's not possible to get access to or inspect the store directly.\n\nFor WeakMaps this means there's no way to find what's inside it or how many items are contained, and the only way to get a reference to a value is if you have a direct reference to the key object that links to it.\n\n# Compatability\n\nWorks with IE9+, Chrome, Firefox, Safari, untested in Opera.\n\n# Collections Usage\n\nMaps, WeakMaps, Hashes, and Sets can each be created using their constructor with or without `new`. Examples:\n\n    var aWeakMap = new WeakMap;\n    var aMap = Map();\n    var aSet = new Set();\n\nItems in a collection do not appear in any manner through traditional inspection. The only way to interact with the data contained in a collection is by using the functions below.\n\n    var aWeakMap = new WeakMap;\n    aWeakMap.set(this, { secrets: 'Dark Secrets' });\n    console.log(Object.getOwnPropertyNames(aWeakMap)); // []\n    for (var k in aWeakMap) { console.log(k); }         // nothing\n    console.log(aWeakMap.get(this));                    // { secrets: 'Dark Secrets' }\n\n\n# WeakMap\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. Keys are per WeakMap are unique and setting the same key will overwrite the old value. WeakMaps provide for no method of iteration or listing the keys or values contained inside. Because WeakMaps expose no method of listing keys or values, and keys are required to be full-fledged objects with unique identities, the only way to extract a value from it is by having a direct reference to the object used as the key.\n\n* __set__ `weakmap.set(key, value)`. Key is any value including objects. Only non-primitives can be used as keys.\n* __get__ `weakmap.get(key)`. Returns the value that key corresponds to the key or undefined.\n* __has__ `weakmap.has(key)`. Returns boolean.\n* __delete__ `weakmap.delete(key)`. Removes value from the WeakMap if found. Returns true.\n\nWeakMaps allow for some interesting use cases like anonymous communication channels where neither side can identify the other, and no one else can eavesdrop. By using using a target object as its own key to retrieve a hidden seceret value no information about the origin can be obtained.\n\n__All non-primitives__ are valid keys, including WeakMaps themselves.\n\n\n# Map\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `map.keys()`. Returns array of contained keys.\n* __values__ `map.values()`. Return array of contained values.\n* __iterate__ `map.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || global, value, key)`.\n* __toArray__ `map.toArray()`. Return array of Pair objects of the form `{ key: KEY, value: VALUE }`.\n\n__All possible values__ are valid keys, including undefined, null, and NaN.\n\n\n# Hash\n\nAs an added bonus, Hash is also exported. This has the same API as a Map except it only accepts primitive keys.\n\n* __set__ `hash.set(key, value)`. Key is any value including objects. Primitives are valid keys but uniqueness is matched by their value since primitives don't have identity. Objects are matched by identity. Returns the value passed in.\n* __get__ `hash.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `hash.has(key)`. Returns boolean.\n* __delete__ `hash.delete(key)`. Removes value from the Map if found. Returns true.\n* __keys__ `hash.keys()`. Returns array of contained keys.\n* __values__ `hash.values()`. Return array of contained values.\n* __iterate__ `hash.iterate(callback, context)`. Loop through the Map executing callback with the signature `callback.call(context || global, value, key)`.\n* __toArray__ `hash.values()`. Return array of Pair objects of the form `{ key: KEY, value: VALUE }`.\n* __toObject__ `hash.toArray()`. Returns a plain object with the keys and values.\n\n__Primitives__ are valid keys, specifically numbers and strings. All input values are coerced to strings so you can give it any value, but they will be converted to string keys.\n\n\n# Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* __add__ `set.add(value)`. Inserts a value of any type into the set if it's not already in the set.\n* __has__ `set.has(value)`. Returns boolean.\n* __delete__ `set.delete(value)`. Removes value from the Set if found. Returns true.\n* __values__ `set.values()`. Return array of contained values.\n* __iterate__ `set.iterate(callback, context)`. Loop through the Set executing callback with the signature `callback.call(context || global, value, index)`.","_id":"harmony-collections@0.2.9","dist":{"shasum":"e11b19193db272a726d73b435b39ecf3a76c3353","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.2.9.tgz"},"maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.3.1":{"author":{"name":"Brandon Benvie","email":"brandon@bbenvie.com","url":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available, with non-leaky O(1) lookup WeakMaps","keywords":["harmony","collection","weakmap","map","set","ecmascript","shim","garbage collection"],"version":"0.3.1","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"https://github.com/Benvie/ES6-Harmony-Collections-Shim"},"main":"harmony-collections.js","engines":{"node":"0.6"},"dependencies":{},"devDependencies":{"tap":"*"},"readme":"# Harmony Collections Shim\n\nProvides Map, Set, and WeakMap with the same usage as the new ES6 native versions. Values in Harmony Collections are not contained in the collection instance itself, like array items and object properties, but in a private store. It's not possible to get access to or inspect the store directly.\n\nFor WeakMaps this means there's no way to find what's inside it or how many items are contained, and the only way to get a reference to a value is if you have a direct reference to the key object that links to it.\n\n# Compatability\n\nWorks with IE9+, Chrome, Firefox, Safari, untested in Opera.\n\n# Collections Usage\n\nMaps, WeakMaps, Hashes, and Sets can each be created using their constructor with or without `new`. Examples:\n\n    var aWeakMap = new WeakMap;\n    var aMap = Map();\n    var aSet = new Set();\n\nItems in a collection do not appear in any manner through traditional inspection. The only way to interact with the data contained in a collection is by using the functions below.\n\n    var aWeakMap = new WeakMap;\n    aWeakMap.set(this, { secrets: 'Dark Secrets' });\n    console.log(Object.getOwnPropertyNames(aWeakMap)); // []\n    for (var k in aWeakMap) { console.log(k); }         // nothing\n    console.log(aWeakMap.get(this));                    // { secrets: 'Dark Secrets' }\n\n\n# WeakMap\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. Keys are per WeakMap are unique and setting the same key will overwrite the old value. WeakMaps provide for no method of iteration or listing the keys or values contained inside. Because WeakMaps expose no method of listing keys or values, and keys are required to be full-fledged objects with unique identities, the only way to extract a value from it is by having a direct reference to the object used as the key.\n\n* __set__ `weakmap.set(key, value)`. Key is any value including objects. Only non-primitives can be used as keys. Returns undefined.\n* __get__ `weakmap.get(key)`. Returns the value that key corresponds to the key or undefined.\n* __has__ `weakmap.has(key)`. Returns boolean.\n* __delete__ `weakmap.delete(key)`. Removes value from the WeakMap if found. Returns true.\n\nWeakMaps allow for some interesting use cases like anonymous communication channels where neither side can identify the other, and no one else can eavesdrop. By using using a target object as its own key to retrieve a hidden seceret value no information about the origin can be obtained.\n\n__All non-primitives__ are valid keys, including WeakMaps themselves.\n\n\n# Map\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Returns undefined.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __forEach__ `map.forEach(callback, context)`. Loop through the collection raising callback for each.\n* __map__ `map.forEach(callback, context)`. Loop through the collection adding the return value for each to an array and returns it.\n\n__All possible values__ are valid keys, including undefined, null, and NaN.\n\n\n# Hash\n\nAs an added bonus, Hash is also exported. This has the same API as a Map except it only accepts primitive keys.\n\n* __set__ `hash.set(key, value)`. Key must be primitive. Returns undefined.\n* __get__ `hash.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `hash.has(key)`. Returns boolean.\n* __delete__ `hash.delete(key)`. Removes value from the Map if found. Returns true.\n* __forEach__ `map.forEach(callback, context)`. Loop through the collection raising callback for each.\n* __map__ `map.forEach(callback, context)`. Loop through the collection adding the return value for each to an array and returns it.\n\n__Primitives__ are valid keys, specifically numbers and strings. All input values are coerced to strings so you can give it any value, but they will be converted to string keys.\n\n\n# Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* __add__ `set.add(value)`. Inserts a value of any type into the set if it's not already in the set.\n* __has__ `set.has(value)`. Returns boolean.\n* __delete__ `set.delete(value)`. Removes value from the Set if found. Returns true.\n* __forEach__ `map.forEach(callback, context)`. Loop through the collection raising callback for each.\n* __map__ `map.forEach(callback, context)`. Loop through the collection adding the return value for each to an array and returns it.\n","_id":"harmony-collections@0.3.1","dist":{"shasum":"34507b5c3f20f6e89c34a2717150770190743ab5","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.3.1.tgz"},"_npmVersion":"1.1.61","_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.3.2":{"author":{"name":"Brandon Benvie","email":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available, with non-leaky O(1) lookup WeakMaps","keywords":["harmony","collection","weakmap","map","set","ecmascript","shim","garbage collection",""],"version":"0.3.2","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"https://github.com/Benvie/ES6-Harmony-Collections-Shim"},"main":"harmony-collections.js","dependencies":{},"devDependencies":{"tap":"*"},"readme":"# Harmony Collections Shim\n\nProvides Map, Set, and WeakMap with the same usage as the new ES6 native versions. Values in Harmony Collections are not contained in the collection instance itself, like array items and object properties, but in a private store. It's not possible to get access to or inspect the store directly.\n\nFor WeakMaps this means there's no way to find what's inside it or how many items are contained, and the only way to get a reference to a value is if you have a direct reference to the key object that links to it.\n\n# Compatability\n\nWorks with IE9+, Chrome, Firefox, Safari, untested in Opera.\n\n# Collections Usage\n\nMaps, WeakMaps, Hashes, and Sets can each be created using their constructor with or without `new`. Examples:\n\n    var aWeakMap = new WeakMap;\n    var aMap = Map();\n    var aSet = new Set();\n\nItems in a collection do not appear in any manner through traditional inspection. The only way to interact with the data contained in a collection is by using the functions below.\n\n    var aWeakMap = new WeakMap;\n    aWeakMap.set(this, { secrets: 'Dark Secrets' });\n    console.log(Object.getOwnPropertyNames(aWeakMap)); // []\n    for (var k in aWeakMap) { console.log(k); }         // nothing\n    console.log(aWeakMap.get(this));                    // { secrets: 'Dark Secrets' }\n\n\n# WeakMap\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. Keys are per WeakMap are unique and setting the same key will overwrite the old value. WeakMaps provide for no method of iteration or listing the keys or values contained inside. Because WeakMaps expose no method of listing keys or values, and keys are required to be full-fledged objects with unique identities, the only way to extract a value from it is by having a direct reference to the object used as the key.\n\n* __set__ `weakmap.set(key, value)`. Key is any value including objects. Only non-primitives can be used as keys. Returns undefined.\n* __get__ `weakmap.get(key)`. Returns the value that key corresponds to the key or undefined.\n* __has__ `weakmap.has(key)`. Returns boolean.\n* __delete__ `weakmap.delete(key)`. Removes value from the WeakMap if found. Returns true.\n\nWeakMaps allow for some interesting use cases like anonymous communication channels where neither side can identify the other, and no one else can eavesdrop. By using using a target object as its own key to retrieve a hidden seceret value no information about the origin can be obtained.\n\n__All non-primitives__ are valid keys, including WeakMaps themselves.\n\n\n# Map\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Returns undefined.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __forEach__ `map.forEach(callback, context)`. Loop through the collection raising callback for each.\n* __map__ `map.forEach(callback, context)`. Loop through the collection adding the return value for each to an array and returns it.\n\n__All possible values__ are valid keys, including undefined, null, and NaN.\n\n\n# Hash\n\nAs an added bonus, Hash is also exported. This has the same API as a Map except it only accepts primitive keys.\n\n* __set__ `hash.set(key, value)`. Key must be primitive. Returns undefined.\n* __get__ `hash.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `hash.has(key)`. Returns boolean.\n* __delete__ `hash.delete(key)`. Removes value from the Map if found. Returns true.\n* __forEach__ `map.forEach(callback, context)`. Loop through the collection raising callback for each.\n* __map__ `map.forEach(callback, context)`. Loop through the collection adding the return value for each to an array and returns it.\n\n__Primitives__ are valid keys, specifically numbers and strings. All input values are coerced to strings so you can give it any value, but they will be converted to string keys.\n\n\n# Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* __add__ `set.add(value)`. Inserts a value of any type into the set if it's not already in the set.\n* __has__ `set.has(value)`. Returns boolean.\n* __delete__ `set.delete(value)`. Removes value from the Set if found. Returns true.\n* __forEach__ `map.forEach(callback, context)`. Loop through the collection raising callback for each.\n* __map__ `map.forEach(callback, context)`. Loop through the collection adding the return value for each to an array and returns it.\n","_id":"harmony-collections@0.3.2","dist":{"shasum":"97fce7558c177d57f40998afdb56bac6718ea7b6","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.3.2.tgz"},"_npmVersion":"1.1.61","_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.3.3":{"author":{"name":"Brandon Benvie","email":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available, with non-leaky O(1) lookup WeakMaps","keywords":["harmony","collection","weakmap","map","set","ecmascript","shim","garbage collection",""],"version":"0.3.3","homepage":"https://github.com/Benvie/ES6-Harmony-Collections-Shim","repository":{"type":"git","url":"https://github.com/Benvie/ES6-Harmony-Collections-Shim"},"main":"harmony-collections.js","dependencies":{},"devDependencies":{"tap":"*"},"license":"MIT","readme":"# Harmony Collections Shim\n\nProvides Map, Set, and WeakMap with the same usage as the new ES6 native versions. Values in Harmony Collections are not contained in the collection instance itself, like array items and object properties, but in a private store. It's not possible to get access to or inspect the store directly.\n\nFor WeakMaps this means there's no way to find what's inside it or how many items are contained, and the only way to get a reference to a value is if you have a direct reference to the key object that links to it.\n\n# Compatability\n\nWorks with IE9+, Chrome, Firefox, Safari, untested in Opera.\n\n# Collections Usage\n\nMaps, WeakMaps, Hashes, and Sets can each be created using their constructor with or without `new`. Examples:\n\n    var aWeakMap = new WeakMap;\n    var aMap = Map();\n    var aSet = new Set();\n\nItems in a collection do not appear in any manner through traditional inspection. The only way to interact with the data contained in a collection is by using the functions below.\n\n    var aWeakMap = new WeakMap;\n    aWeakMap.set(this, { secrets: 'Dark Secrets' });\n    console.log(Object.getOwnPropertyNames(aWeakMap)); // []\n    for (var k in aWeakMap) { console.log(k); }         // nothing\n    console.log(aWeakMap.get(this));                    // { secrets: 'Dark Secrets' }\n\n\n# WeakMap\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. Keys are per WeakMap are unique and setting the same key will overwrite the old value. WeakMaps provide for no method of iteration or listing the keys or values contained inside. Because WeakMaps expose no method of listing keys or values, and keys are required to be full-fledged objects with unique identities, the only way to extract a value from it is by having a direct reference to the object used as the key.\n\n* __set__ `weakmap.set(key, value)`. Key is any value including objects. Only non-primitives can be used as keys. Returns undefined.\n* __get__ `weakmap.get(key)`. Returns the value that key corresponds to the key or undefined.\n* __has__ `weakmap.has(key)`. Returns boolean.\n* __delete__ `weakmap.delete(key)`. Removes value from the WeakMap if found. Returns true.\n\nWeakMaps allow for some interesting use cases like anonymous communication channels where neither side can identify the other, and no one else can eavesdrop. By using using a target object as its own key to retrieve a hidden seceret value no information about the origin can be obtained.\n\n__All non-primitives__ are valid keys, including WeakMaps themselves.\n\n\n# Map\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Returns undefined.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the Map if found. Returns true.\n* __forEach__ `map.forEach(callback, context)`. Loop through the collection raising callback for each.\n* __map__ `map.forEach(callback, context)`. Loop through the collection adding the return value for each to an array and returns it.\n\n__All possible values__ are valid keys, including undefined, null, and NaN.\n\n\n# Hash\n\nAs an added bonus, Hash is also exported. This has the same API as a Map except it only accepts primitive keys.\n\n* __set__ `hash.set(key, value)`. Key must be primitive. Returns undefined.\n* __get__ `hash.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `hash.has(key)`. Returns boolean.\n* __delete__ `hash.delete(key)`. Removes value from the Map if found. Returns true.\n* __forEach__ `map.forEach(callback, context)`. Loop through the collection raising callback for each.\n* __map__ `map.forEach(callback, context)`. Loop through the collection adding the return value for each to an array and returns it.\n\n__Primitives__ are valid keys, specifically numbers and strings. All input values are coerced to strings so you can give it any value, but they will be converted to string keys.\n\n\n# Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* __add__ `set.add(value)`. Inserts a value of any type into the set if it's not already in the set.\n* __has__ `set.has(value)`. Returns boolean.\n* __delete__ `set.delete(value)`. Removes value from the Set if found. Returns true.\n* __forEach__ `map.forEach(callback, context)`. Loop through the collection raising callback for each.\n* __map__ `map.forEach(callback, context)`. Loop through the collection adding the return value for each to an array and returns it.\n\n\n\n\n## License\n\n(The MIT License)\nCopyright (c) 2012 Brandon Benvie <http://bbenvie.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files\n(the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included with all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\nFOR ANY  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH\nTHE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n","_id":"harmony-collections@0.3.3","dist":{"shasum":"38fc811e07714001831c2c386aaf78b287033608","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.3.3.tgz"},"_npmVersion":"1.1.61","_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.3.4":{"author":{"name":"Brandon Benvie","email":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available, with non-leaky O(1) lookup WeakMaps","keywords":["harmony","collection","weakmap","map","set","ecmascript","es6","shim","garbage collection","gc"],"version":"0.3.4","homepage":"http://benvie.github.com/harmony-collections","repository":{"type":"git","url":"https://github.com/Benvie/harmony-collections"},"main":"harmony-collections.js","dependencies":{},"devDependencies":{"tap":"*"},"license":"MIT","readme":"# Harmony Collections Shim\n\nUse the new __Map__, __Set__, and __WeakMap__ from the upcoming ES6 standard right now! This shim provides full functionality for these collections and delivers the benefits of using them.\n\n## Compatability\n\nWorks with IE9+, Chrome, Firefox, Safari, untested in Opera. __IE8 support has been recently added but is experimental.__\n\n## Install/Use\n\nIf using node, install via:\n\n    npm install harmony-collections\n\nIn the browser, include __harmony-collection.js__ or __harmony-collections.min.js__ and Map, WeakMap, Set, and HashMap will be exposed on the window. (you can also define `window.exports` which will cause them to end up there).\n\n## Overview\n\nES6 Collections provide a new core weapon to your JS arsenal: objects as keys. This allows you to do the following awesome things: store private data \"on\" public objects, private properties, secretly \"tag\" objects, namespace properties, access controlled properties, check object uniqueness in __O(1)__ time complexity.\n\n### WeakMap Garbage Collection Semantics\n\nThe benefit of using WeakMaps is enhanced garbage collection. In a WeakMap, the only reference created is key -> value, so it's possible for a key/value in a WeakMap to be garbage collected while the WeakMap they're in still exists! Compare this to an Array, where all items in the Array will not be garbage collected as long as the Array isn't. This forces either explicitly management of the object lifespans, or more commonly is simply a memory leak.\n\nFor example, data stored using jQuery.data can never be garbage collected unless explicitly nulled out, because it is stored in a container that strongly references it. Using a WeakMap, it's possible to associate data with an element and have the data destroyed when the element is without memory leaking the element, i.e. `weakmap.set(element, { myData: 'gc safe!' })`. jQuery.data (every library has similar functionality) prevent the element from memory leaking by using a numeric id, but this does nothing for the __data__ that is stored.\n\n## Detailed Examples\n\n### Map/WeakMap\nRetire jQuery.data and similar, consider it replaced with prejudice.\n\n```javascript\n// reusable storage creator for making as many separate stores as needed\nfunction createStorage(){\n  var store = new WeakMap;\n  return function(o){\n    var v = store.get(o);\n    if (!v) store.set(o, v = {});\n    return v;\n  };\n}\n\n// now we can create private/namespaced properties associated with objects\nvar _ = createStorage();\n\nfunctioon Wrapper(element){\n  var _element = _(element);\n  if (_element.wrapper)\n    return _element.wrapper;\n\n  _element.wrapper = this;\n  _(this).element = element;\n}\n\nWrapper.prototype = {\n  get classes(){\n    return [].slice.call(_(this).element);\n  },\n  set classes(v){\n    _(this).element.className = [].concat(v).join(' ');\n  }\n};\n```\n\n### Set\nA Set is similar to an Array in what it stores, but different in how. A Set is unordered and its values are unique. Determining whether an item is in a Set is __O(1)__ but __O(n)__ for an Array. An example of where this is useful is in implementing `Array.prototype.unique`.\n\n```javascript\nfunction uniqueUsingIndexOf(array){\n  return array.filter(function(item, index){\n    return array.lastIndexOf(item) > index;\n  });\n}\n\nfunction uniqueUsingSet(array){\n  var seen = new Set;\n  return array.filter(function(item){\n    if (!seen.has(item)) {\n      seen.add(item);\n      return true;\n    }\n  });\n}\n```\n\nBoth will output the same result, however the version using the set is __O(n)__ and the one using indexOf is __O(n^2)__. For an array taking 30 seconds using the set, an __*hour*__ is required for indexOf.\n\n## API Reference\n\n### WeakMap\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. Keys are unique per WeakMap; setting the same key will overwrite the old value. WeakMaps have no way to enumerate their keys or values. Because of this, the only way to retrieve a value from a WeakMap is to have access to both the WeakMap itself as well as the object used as the key.\n\n* __set__ `weakmap.set(key, value)`. Key is any value including objects. Only non-primitives can be used as keys. Returns undefined.\n* __get__ `weakmap.get(key)`. Returns the value that key corresponds to the key or undefined.\n* __has__ `weakmap.has(key)`. Returns boolean.\n* __delete__ `weakmap.delete(key)`. Removes value from the collection if found. Returns true.\n\nWeakMaps allow for some interesting use cases like anonymous communication channels where neither side can identify the other, and no one else can eavesdrop. By using using a target object as its own key to retrieve a hidden seceret value no information about the origin can be obtained.\n\n__Non-primitives__ are valid keys. Objects, functions, DOM nodes, etc.\n\n\n### HashMap\n\nThough not part of ES6, HashMap is also exported. This has the same API as a Map except it only accepts primitive keys. This is needed to implement Map so as a bonus it's exported as well.\n\n* __set__ `hashmap.set(key, value)`. Key must be primitive. Returns undefined.\n* __get__ `hashmap.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `hashmap.has(key)`. Returns boolean.\n* __delete__ `hashmap.delete(key)`. Removes value from the collection if found. Returns true.\n* __forEach__ `hashmap.forEach(callback, context)`. Loop through the collection raising callback for each.\n* __map__ `hashmap.map(callback, context)`. Loop through the collection adding the return value for each to an array and returns it.\n\n__Primitives__ are valid keys. Exact value is used, so `500` is different from `\"500\"`, `-0` is different from `0`, ``\"false\"` isn't `false`, etc. NaN does equal itself when used as a key (as opposed to everywhere else in JS).\n\n\n### Map\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* __set__ `map.set(key, value)`. Key is any value including objects. Returns undefined.\n* __get__ `map.get(key)`. Returns the value that key corresponds to or undefined.\n* __has__ `map.has(key)`. Returns boolean.\n* __delete__ `map.delete(key)`. Removes value from the collection if found. Returns true.\n* __forEach__ `map.forEach(callback, context)`. Loop through the collection raising callback for each.\n* __map__ `map.map(callback, context)`. Loop through the collection adding the return value for each to an array and returns it.\n\n__All possible values__ are valid keys, including -0, undefined, null, and NaN. Uses a HashMap and WeakMap together to cover primitives and non-primitives.\n\n\n\n### Set\n\nSets are similar to arrays but enforce uniqueness of values and are unordered. Adding the same value twice will only result in one being added to the set.\n\n* __add__ `set.add(value)`. Inserts a value of any type into the set if it's not already in the set.\n* __has__ `set.has(value)`. Returns boolean.\n* __delete__ `set.delete(value)`. Removes value from the collection if found. Returns true.\n* __forEach__ `set.forEach(callback, context)`. Loop through the collection raising callback for each.\n* __map__ `set.map(callback, context)`. Loop through the collection adding the return value for each to an array and returns it.\n\n\n\n\n## License\n\n(The MIT License)\nCopyright (c) 2012 Brandon Benvie <http://bbenvie.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files\n(the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included with all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\nFOR ANY  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH\nTHE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n","_id":"harmony-collections@0.3.4","dist":{"shasum":"4091852c57f56c7c41138ada2ed785044878e726","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.3.4.tgz"},"_npmVersion":"1.1.61","_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.3.5":{"author":{"name":"Brandon Benvie","email":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available, with non-leaky O(1) lookup WeakMaps","keywords":["harmony","collection","weakmap","map","set","ecmascript","es6","shim","garbage collection","gc"],"version":"0.3.5","homepage":"http://benvie.github.com/harmony-collections","repository":{"type":"git","url":"https://github.com/Benvie/harmony-collections"},"main":"harmony-collections.js","dependencies":{},"devDependencies":{"tap":"*"},"license":"MIT","readme":"# Harmony Collections Shim\n\nUse the new __Map__, __Set__, and __WeakMap__ from the upcoming ES6 standard right now! This shim provides full functionality for these collections and delivers the benefits of using them.\n\n## Compatability\n\nWorks with IE9+, Chrome, Firefox, Safari, untested in Opera. __IE8 support has been recently added but is experimental.__\n\n## Install/Use\n\nIf using node, install via:\n\n    npm install harmony-collections\n\nIn the browser, include __harmony-collection.js__ or __harmony-collections.min.js__ and Map, WeakMap, Set, and HashMap will be exposed on the window. (you can also define `window.exports` which will cause them to end up there).\n\n## Overview\n\nES6 Collections provide a new core weapon to your JS arsenal: objects as keys. This allows you to do the following awesome things: store private data \"on\" public objects, private properties, secretly \"tag\" objects, namespace properties, access controlled properties, check object uniqueness in `O(1)` time complexity.\n\n### WeakMap Garbage Collection Semantics\n\nThe benefit of using WeakMaps is enhanced garbage collection. In a WeakMap, the only reference created is key -> value, so it's possible for a key/value in a WeakMap to be garbage collected while the WeakMap they're in still exists! Compare this to an Array, where all items in the Array will not be garbage collected as long as the Array isn't. This forces either explicitly management of the object lifespans, or more commonly is simply a memory leak.\n\nFor example, data stored using jQuery.data can never be garbage collected unless explicitly nulled out, because it is stored in a container that strongly references it. Using a WeakMap, it's possible to associate data with an element and have the data destroyed when the element is without memory leaking the element, i.e. `weakmap.set(element, { myData: 'gc safe!' })`. jQuery.data (every library has similar functionality) prevent the element from memory leaking by using a numeric id, but this does nothing for the __data__ that is stored.\n\n## Detailed Examples\n\n### Map/WeakMap\nRetire jQuery.data and similar, consider it replaced with prejudice.\n\n```javascript\n// reusable storage creator for making as many separate stores as needed\nfunction createStorage(){\n  var store = new WeakMap;\n  return function(o){\n    var v = store.get(o);\n    if (!v) store.set(o, v = {});\n    return v;\n  };\n}\n\n// now we can create private/namespaced properties associated with objects\nvar _ = createStorage();\n\nfunctioon Wrapper(element){\n  var _element = _(element);\n  if (_element.wrapper)\n    return _element.wrapper;\n\n  _element.wrapper = this;\n  _(this).element = element;\n}\n\nWrapper.prototype = {\n  get classes(){\n    return [].slice.call(_(this).element);\n  },\n  set classes(v){\n    _(this).element.className = [].concat(v).join(' ');\n  }\n};\n```\n\n### Set\nA Set is similar to an Array in what it stores, but different in how. A Set is unordered and its values are unique. Determining whether an item is in a Set is `O(1)` but `O(n)` for an Array. An example of where this is useful is in implementing `Array.prototype.unique`.\n\nBoth of the following will output the same result, however the Set version is `O(n)` and the one using indexOf is `O(n^2)`. For an array taking 30 seconds using the set, an __*hour*__ is required for indexOf.\n\n```javascript\nfunction uniqueUsingIndexOf(array){\n  return array.filter(function(item, index){\n    return array.lastIndexOf(item) > index;\n  });\n}\n\nfunction uniqueUsingSet(array){\n  var seen = new Set;\n  return array.filter(function(item){\n    if (!seen.has(item)) {\n      seen.add(item);\n      return true;\n    }\n  });\n}\n```\n\n\n## API Reference\n\n### WeakMap\n\n__Non-primitives__ are valid keys. Objects, functions, DOM nodes, etc.\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. WeakMaps have no way to enumerate their keys or values. Because of this, the only way to retrieve a value from a WeakMap is to have access to both the WeakMap itself as well as the object used as the key.\n\n* `WeakMap#set(key, value)` Key is any value including objects. Only non-primitives can be used as keys. Returns undefined.\n* `WeakMap#get(key)` Returns the value that key corresponds to the key or undefined.\n* `WeakMap#has(key)` Returns boolean.\n* `WeakMap#delete(key)` Removes value from the collection if found. Returns true.\n\n\n### HashMap\n\n__Primitives__ are valid keys. Exact value is used, so `500` is different from `\"500\"`, `-0` is different from `0`, ``\"false\"` isn't `false`, etc. NaN does equal itself when used as a key (as opposed to everywhere else in JS).\n\nThough not part of ES6, HashMap is also exported. This has the same API as a Map except it only accepts primitive keys. This is needed to implement Map so as a bonus it's exported as well.\n\n* `HashMap#set(key, value)` Key must be primitive. Returns undefined.\n* `HashMap#get(key)` Returns the value that key corresponds to or undefined.\n* `HashMap#has(key)` Returns boolean.\n* `HashMap#delete(key)` Removes value from the collection if found. Returns true.\n* `HashMap#forEach(callback, context)` Loop through the collection raising callback for each.\n* `HashMap#map(callback, context)` Loop through the collection adding the return value for each to an array and returns it.\n\n\n### Map\n\n__All possible values__ are valid keys, including -0, undefined, null, and NaN. Uses a HashMap and WeakMap together to cover primitives and non-primitives.\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* `Map#set(key, value)` Key is any value including objects. Returns undefined.\n* `Map#get(key)` Returns the value that key corresponds to or undefined.\n* `Map#has(key)` Returns boolean.\n* `Map#delete(key)` Removes value from the collection if found. Returns true.\n* `Map#forEach(callback, context)` Loop through the collection raising callback for each.\n* `Map#map(callback, context)` Loop through the collection adding the return value for each to an array and returns it.\n\n\n### Set\n\nSets are similar to arrays but enforce uniqueness of values and are unordered. Adding the same value twice will only result in one being added to the set.\n\n* `Set#add(value)` Inserts a value of any type into the set if it's not already in the set.\n* `Set#has(value)` Returns boolean.\n* `Set#delete(value)` Removes value from the collection if found. Returns true.\n* `Set#forEach(callback, context)` Loop through the collection raising callback for each.\n* `Set#map(callback, context)` Loop through the collection adding the return value for each to an array and returns it.\n\n\n\n## License\n\n(The MIT License)\nCopyright (c) 2012 Brandon Benvie <http://bbenvie.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files\n(the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included with all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\nFOR ANY  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH\nTHE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n","_id":"harmony-collections@0.3.5","dist":{"shasum":"5648621726d6700b4af29f38cae28a6dbeea452d","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.3.5.tgz"},"_npmVersion":"1.1.61","_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.3.6":{"author":{"name":"Brandon Benvie","email":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available, with non-leaky O(1) lookup WeakMaps","keywords":["harmony","collection","weakmap","map","set","ecmascript","es6","shim","garbage collection","gc"],"version":"0.3.6","homepage":"http://benvie.github.com/harmony-collections","repository":{"type":"git","url":"https://github.com/Benvie/harmony-collections"},"main":"harmony-collections.js","dependencies":{},"devDependencies":{"tap":"*"},"license":"MIT","readme":"# Harmony Collections Shim\n\nUse the new __Map__, __Set__, and __WeakMap__ from the upcoming ES6 standard right now! This shim provides full functionality for these collections and delivers the benefits of using them.\n\n## Compatability\n\nWorks with IE9+, Chrome, Firefox, Safari, untested in Opera. __IE8 support has been recently added but is experimental.__\n\n## Install/Use\n\nIf using node, install via:\n\n    npm install harmony-collections\n\nIn the browser, include __harmony-collection.js__ or __harmony-collections.min.js__ and Map, WeakMap, Set, and HashMap will be exposed on the window. (you can also define `window.exports` which will cause them to end up there).\n\n## Overview\n\nES6 Collections provide a new core weapon to your JS arsenal: objects as keys. This allows you to do the following awesome things: store private data \"on\" public objects, private properties, secretly \"tag\" objects, namespace properties, access controlled properties, check object uniqueness in `O(1)` time complexity.\n\n### WeakMap Garbage Collection Semantics\n\nThe benefit of using WeakMaps is enhanced garbage collection. In a WeakMap, the only reference created is key -> value, so it's possible for a key/value in a WeakMap to be garbage collected while the WeakMap they're in still exists! Compare this to an Array, where all items in the Array will not be garbage collected as long as the Array isn't. This forces either explicitly management of the object lifespans, or more commonly is simply a memory leak.\n\nFor example, data stored using jQuery.data can never be garbage collected unless explicitly nulled out, because it is stored in a container that strongly references it. Using a WeakMap, it's possible to associate data with an element and have the data destroyed when the element is without memory leaking the element, i.e. `weakmap.set(element, { myData: 'gc safe!' })`. jQuery.data (every library has similar functionality) prevent the element from memory leaking by using a numeric id, but this does nothing for the __data__ that is stored.\n\n## Detailed Examples\n\n### Map/WeakMap\nRetire jQuery.data and similar, consider it replaced with prejudice.\n\n```javascript\n// reusable storage creator\nfunction createStorage(){\n  var store = new WeakMap;\n  return function(o){\n    var v = store.get(o);\n    if (!v) store.set(o, v = {});\n    return v;\n  };\n}\n\n// allows private/namespaced properties for the objects\nvar _ = createStorage();\n\nfunctioon Wrapper(element){\n  var _element = _(element);\n  if (_element.wrapper)\n    return _element.wrapper;\n\n  _element.wrapper = this;\n  _(this).element = element;\n}\n\nWrapper.prototype = {\n  get classes(){\n    return [].slice.call(_(this).element);\n  },\n  set classes(v){\n    _(this).element.className = [].concat(v).join(' ');\n  }\n};\n```\n\n### Set\nA Set is similar to an Array in what it stores, but different in how. A Set is unordered and its values are unique. Determining whether an item is in a Set is `O(1)` but `O(n)` for an Array. An example of where this is useful is in implementing `Array.prototype.unique`.\n\nBoth of the following will output the same result, however the Set version is `O(n)` and the one using indexOf is `O(n^2)`. For an array taking 30 seconds using the set, an __*hour*__ is required for indexOf.\n\n```javascript\nfunction uniqueUsingIndexOf(array){\n  return array.filter(function(item, index){\n    return array.lastIndexOf(item) > index;\n  });\n}\n\nfunction uniqueUsingSet(array){\n  var seen = new Set;\n  return array.filter(function(item){\n    if (!seen.has(item)) {\n      seen.add(item);\n      return true;\n    }\n  });\n}\n```\n\n\n## API Reference\n\n### WeakMap\n\n__Non-primitives__ are valid keys. Objects, functions, DOM nodes, etc.\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. WeakMaps have no way to enumerate their keys or values. Because of this, the only way to retrieve a value from a WeakMap is to have access to both the WeakMap itself as well as the object used as the key.\n\n* `new WeakMap()` Create a new WeakMap.\n* `WeakMap#set(key, value)` Key is any value including objects. Only non-primitives can be used as keys. Returns undefined.\n* `WeakMap#get(key)` Returns the value that key corresponds to the key or undefined.\n* `WeakMap#has(key)` Returns boolean.\n* `WeakMap#delete(key)` Removes value from the collection if found. Returns true.\n\n\n### HashMap\n\n__Primitives__ are valid keys. Exact value is used, so `500` is different from `\"500\"`, `-0` is different from `0`, ``\"false\"` isn't `false`, etc. NaN does equal itself when used as a key (as opposed to everywhere else in JS).\n\nThough not part of ES6, HashMap is also exported. This has the same API as a Map except it only accepts primitive keys. This is needed to implement Map so as a bonus it's exported as well.\n\n* `new HashMap(iterable)` Create a new HashMap populated with the iterable. Accepts __[[Key, Value]..], Array, Object, Collection__.\n* `HashMap#set(key, value)` Key must be primitive. Returns undefined.\n* `HashMap#get(key)` Returns the value that key corresponds to or undefined.\n* `HashMap#has(key)` Returns boolean.\n* `HashMap#delete(key)` Removes value from the collection if found. Returns true.\n* `HashMap#size()` Returns the number of items in the collection.\n* `HashMap#forEach(callback, context)` Loop through the collection raising callback for each.\n\n\n### Map\n\n__All possible values__ are valid keys, including -0, undefined, null, and NaN. Uses a HashMap and WeakMap together to cover primitives and non-primitives.\n\nMaps are much the same as WeakMaps but they can be iterated and thus their contents can be inspected. Many use cases have no requirement for anonymity or special garbage collection, but can benefit from using objects as keys and also not having the storage contained in the Map itself.\n\n* `new Map(iterable)` Create a new Map populated with the iterable. Accepts __[[Key, Value]..], Array, Object, Collection__.\n* `Map#set(key, value)` Key is any value including objects. Returns undefined.\n* `Map#get(key)` Returns the value that key corresponds to or undefined.\n* `Map#has(key)` Returns boolean.\n* `Map#delete(key)` Removes value from the collection if found. Returns true.\n* `Map#size()` Returns the number of items in the collection.\n* `Map#forEach(callback, context)` Loop through the collection raising callback for each.\n\n\n### Set\n\nSets are similar to arrays but enforce uniqueness of values and are unordered. Adding the same value twice will only result in one being added to the set.\n\n* `new Set(iterable)` Create a new Set populated with the iterable. Accepts __Array, Object, Collection__.\n* `Set#add(value)` Inserts a value of any type into the set if it's not already in the set.\n* `Set#has(value)` Returns boolean.\n* `Set#delete(value)` Removes value from the collection if found. Returns true.\n* `Set#size()` Returns the number of items in the collection.\n* `Set#forEach(callback, context)` Loop through the collection raising callback for each.\n\n\n\n## License\n\n(The MIT License)\nCopyright (c) 2012 Brandon Benvie <http://bbenvie.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files\n(the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included with all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\nFOR ANY  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH\nTHE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n","_id":"harmony-collections@0.3.6","dist":{"shasum":"9d870ded2cd616f7a2ef52f6307020e29a44d7ce","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.3.6.tgz"},"_npmVersion":"1.1.61","_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.3.7":{"author":{"name":"Brandon Benvie","email":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available, with non-leaky O(1) lookup WeakMaps","keywords":["harmony","collection","weakmap","map","set","ecmascript","es6","shim","garbage collection","gc"],"version":"0.3.7","homepage":"http://benvie.github.com/harmony-collections","repository":{"type":"git","url":"https://github.com/Benvie/harmony-collections"},"main":"harmony-collections.js","dependencies":{},"devDependencies":{"tap":"*"},"license":"MIT","readme":"# Harmony Collections Shim\n\nUse the new __Map__, __Set__, and __WeakMap__ from the upcoming ES6 standard right now! This shim provides full functionality for these collections and delivers the benefits of using them.\n\n## Compatability\n\nWorks with IE9+, Chrome, Firefox, Safari, untested in Opera. __IE8 support has been recently added but is experimental.__\n\n## Install/Use\n\nIf using node, install via:\n\n    npm install harmony-collections\n\nIn the browser, include __harmony-collection.js__ or __harmony-collections.min.js__ and Map, WeakMap, Set, and HashMap will be exposed on the window. (you can also define `window.exports` which will cause them to end up there).\n\n## Overview\n\nES6 Collections provide a new core weapon to your JS arsenal: objects as keys. This allows you to do the following awesome things: store private data \"on\" public objects, private properties, secretly \"tag\" objects, namespace properties, access controlled properties, check object uniqueness in `O(1)` time complexity.\n\n### WeakMap Garbage Collection Semantics\n\nThe benefit of using WeakMaps is enhanced garbage collection. In a WeakMap, the only reference created is key -> value, so it's possible for a key/value in a WeakMap to be garbage collected while the WeakMap they're in still exists! Compare this to an Array, where all items in the Array will not be garbage collected as long as the Array isn't. This forces either explicit management of  object lifespans or, more commonly, simply results in memory leaks.\n\nFor example, data stored using jQuery.data can never be garbage collected unless explicitly nulled out, because it is stored in a container that strongly references the items held inside. Using a WeakMap, it's possible to associate data with an element and have the data destroyed when the element is -- without memory leaking the element; i.e. `weakmap.set(element, { myData: 'gc safe!' })`. jQuery.data (every library has similar functionality) prevents the *element* from memory leaking by using a numeric id, but this does nothing for the __data__ that is stored.\n\n## Detailed Examples\n\n### Map/WeakMap\n```javascript\n// reusable storage creator\nfunction createStorage(){\n  var store = new WeakMap;\n  return function(o){\n    var v = store.get(o);\n    if (!v) store.set(o, v = {});\n    return v;\n  };\n}\n\n// allows private/namespaced properties for the objects\nvar _ = createStorage();\n\nfunctioon Wrapper(element){\n  var _element = _(element);\n  if (_element.wrapper)\n    return _element.wrapper;\n\n  _element.wrapper = this;\n  _(this).element = element;\n}\n\nWrapper.prototype = {\n  get classes(){\n    return [].slice.call(_(this).element.classList);\n  },\n  set classes(v){\n    _(this).element.className = [].concat(v).join(' ');\n  }\n};\n```\n\n### Set\nA Set is similar to an Array in what it stores, but different in how. A Set's values are unique. Determining whether an item is in a Set is `O(1)` but `O(n)` for an Array. An example of where this is useful is in implementing `Array.prototype.unique` that works with objects.\n\nBoth of the following will output the same result, however the Set version is `O(n)` and the one using indexOf is `O(n^2)`. For an array taking 30 seconds using the set, an __*hour*__ is required for indexOf.\n\n```javascript\nfunction uniqueUsingIndexOf(array){\n  return array.filter(function(item, index){\n    return array.lastIndexOf(item) > index;\n  });\n}\n\nfunction uniqueUsingSet(array){\n  var seen = new Set;\n  return array.filter(function(item){\n    if (!seen.has(item)) {\n      seen.add(item);\n      return true;\n    }\n  });\n}\n```\n\n\n## API Reference\n\n* Collections may be inherited from. Initialize objects via `[WeakMap|Map|Set].call(obj)`.\n* Iteration is insertion ordered.\n\n\n### WeakMap\n\n__Non-primitives__ are valid keys. Objects, functions, DOM nodes, etc.\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. WeakMaps have no way to enumerate their keys or values. Because of this, the only way to retrieve a value from a WeakMap is to have access to both the WeakMap itself as well as an object used as a key.\n\n* `new WeakMap(iterable)` Create a new WeakMap populated with the iterable. Accepts *[[Key, Value]...]*, *Array*, *Iterable*.\n* `WeakMap#set(key, value)` Key must be non-primitive. Returns undefined.\n* `WeakMap#get(key)` Returns the value that key corresponds to the key or undefined.\n* `WeakMap#has(key)` Returns boolean.\n* `WeakMap#delete(key)` Removes the value from the collection and returns boolean indicating if there was a value to delete.\n\n\n### HashMap\n\n__Primitives__ are valid keys. Exact value is used; e.g. `'0'/-0/0` are all different keys.\n\nHashMap is not standard, but is used to implement Map and is exported as a bonus. Has the same API as Map except it only allows primitive keys.\n\n* `new HashMap(iterable)` Create a new HashMap populated with the iterable. Accepts *[[Key, Value]...]*, *Iterable*.\n* `HashMap#set(key, value)` Key must be primitive. Returns undefined.\n* `HashMap#get(key)` Returns the value the key corresponds to or undefined.\n* `HashMap#has(key)` Returns boolean.\n* `HashMap#delete(key)` Removes the value from the collection and returns boolean indicating if there was a value to delete.\n* `HashMap#size()` Returns the number of items in the collection.\n* `HashMap#forEach(callback, context)` Loop through the collection raising callback for each.\n\n\n### Map\n\n__All possible values__ are valid keys, including -0, undefined, null, and NaN.\n\nMaps do not have the same garbage collection benefits that WeakMaps do, but instead are iterable and also accept primitive keys. This means any value can be a Map key.\n\n* `new Map(iterable)` Create a new Map populated with the iterable. Accepts *[[Key, Value]...]*, *Array*, *Iterable*.\n* `Map#set(key, value)` Key is any value including objects. Returns undefined.\n* `Map#get(key)` Returns the value the key maps to or undefined.\n* `Map#has(key)` Returns boolean.\n* `Map#delete(key)` Removes the key and value from the collection if found. Returns true.\n* `Map#size()` Returns the number of items in the collection.\n* `Map#forEach(callback, context)` Loop through the collection raising callback for each.\n\n\n### Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* `new Set(iterable)` Create a new Set populated with the iterable. Accepts *Array*, *Iterable*.\n* `Set#add(value)` Inserts a value of any type into the set if it's not already in the set.\n* `Set#has(value)` Returns boolean.\n* `Set#delete(value)` Removes the value from the collection and returns boolean indicating if there was a value to delete.\n* `Set#size()` Returns the number of items in the collection.\n* `Set#forEach(callback, context)` Loop through the collection raising callback for each.\n\n\n\n## License\n\n(The MIT License)\nCopyright (c) 2012 Brandon Benvie <http://bbenvie.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files\n(the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included with all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\nFOR ANY  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH\nTHE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n","_id":"harmony-collections@0.3.7","dist":{"shasum":"3bc05ec1c3af796daa40b23245d33cc36f812d50","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.3.7.tgz"},"_npmVersion":"1.1.61","_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}},"0.3.8":{"author":{"name":"Brandon Benvie","email":"http://bbenvie.com"},"name":"harmony-collections","description":"Shim to provide Map, Set, and WeakMap if they're not available, with non-leaky O(1) lookup WeakMaps","keywords":["harmony","collection","weakmap","map","set","ecmascript","es6","shim","garbage collection","gc"],"version":"0.3.8","homepage":"http://benvie.github.com/harmony-collections","repository":{"type":"git","url":"https://github.com/Benvie/harmony-collections"},"main":"harmony-collections.js","dependencies":{},"devDependencies":{"tap":"*"},"license":"MIT","readme":"# Harmony Collections Shim\n\nUse the new __Map__, __Set__, and __WeakMap__ from the upcoming ES6 standard right now! This shim provides full functionality for these collections and delivers the benefits of using them.\n\n## Compatability\n\nWorks with IE9+, Chrome, Firefox, Safari, untested in Opera. __IE8 support has been recently added but is experimental.__\n\n## Install/Use\n\nIf using node, install via:\n\n    npm install harmony-collections\n\nIn the browser, include __harmony-collection.js__ or __harmony-collections.min.js__ and Map, WeakMap, Set, and HashMap will be exposed on the window. (you can also define `window.exports` which will cause them to end up there).\n\n## Overview\n\nES6 Collections provide a new core weapon to your JS arsenal: objects as keys. This allows you to do the following awesome things: store private data \"on\" public objects, private properties, secretly \"tag\" objects, namespace properties, access controlled properties, check object uniqueness in `O(1)` time complexity.\n\n### WeakMap Garbage Collection Semantics\n\nThe benefit of using WeakMaps is enhanced garbage collection. In a WeakMap, the only reference created is key -> value, so it's possible for a key/value in a WeakMap to be garbage collected while the WeakMap they're in still exists! Compare this to an Array, where all items in the Array will not be garbage collected as long as the Array isn't. This forces either explicit management of  object lifespans or, more commonly, simply results in memory leaks.\n\nFor example, data stored using jQuery.data can never be garbage collected unless explicitly nulled out, because it is stored in a container that strongly references the items held inside. Using a WeakMap, it's possible to associate data with an element and have the data destroyed when the element is -- without memory leaking the element; i.e. `weakmap.set(element, { myData: 'gc safe!' })`. jQuery.data (every library has similar functionality) prevents the *element* from memory leaking by using a numeric id, but this does nothing for the __data__ that is stored.\n\n## Detailed Examples\n\n### Map/WeakMap\n```javascript\n// reusable storage creator\nfunction createStorage(){\n  var store = new WeakMap;\n  return function(o){\n    var v = store.get(o);\n    if (!v) store.set(o, v = {});\n    return v;\n  };\n}\n\n// allows private/namespaced properties for the objects\nvar _ = createStorage();\n\nfunctioon Wrapper(element){\n  var _element = _(element);\n  if (_element.wrapper)\n    return _element.wrapper;\n\n  _element.wrapper = this;\n  _(this).element = element;\n}\n\nWrapper.prototype = {\n  get classes(){\n    return [].slice.call(_(this).element.classList);\n  },\n  set classes(v){\n    _(this).element.className = [].concat(v).join(' ');\n  }\n};\n```\n\n### Set\nA Set is similar to an Array in what it stores, but different in how. A Set's values are unique. Determining whether an item is in a Set is `O(1)` but `O(n)` for an Array. An example of where this is useful is in implementing `Array.prototype.unique` that works with objects.\n\nBoth of the following will output the same result, however the Set version is `O(n)` and the one using indexOf is `O(n^2)`. For an array taking 30 seconds using the set, an __*hour*__ is required for indexOf.\n\n```javascript\nfunction uniqueUsingIndexOf(array){\n  return array.filter(function(item, index){\n    return array.lastIndexOf(item) > index;\n  });\n}\n\nfunction uniqueUsingSet(array){\n  var seen = new Set;\n  return array.filter(function(item){\n    if (!seen.has(item)) {\n      seen.add(item);\n      return true;\n    }\n  });\n}\n```\n\n\n## API Reference\n\n* Collections may be inherited from. Initialize objects via `[WeakMap|Map|Set].call(obj)`.\n* Iteration is insertion ordered.\n\n\n### WeakMap\n\n__Non-primitives__ are valid keys. Objects, functions, DOM nodes, etc.\n\nWeakMaps require the use of objects as keys; primitives are not valid keys. WeakMaps have no way to enumerate their keys or values. Because of this, the only way to retrieve a value from a WeakMap is to have access to both the WeakMap itself as well as an object used as a key.\n\n* `new WeakMap(iterable)` Create a new WeakMap populated with the iterable. Accepts *[[Key, Value]...]*, *Array*, *Iterable*.\n* `WeakMap#set(key, value)` Key must be non-primitive. Returns undefined.\n* `WeakMap#get(key)` Returns the value that key corresponds to the key or undefined.\n* `WeakMap#has(key)` Returns boolean.\n* `WeakMap#delete(key)` Removes the value from the collection and returns boolean indicating if there was a value to delete.\n\n\n### HashMap\n\n__Primitives__ are valid keys. Exact value is used; e.g. `'0'/-0/0` are all different keys.\n\nHashMap is not standard, but is used to implement Map and is exported as a bonus. Has the same API as Map except it only allows primitive keys.\n\n* `new HashMap(iterable)` Create a new HashMap populated with the iterable. Accepts *[[Key, Value]...]*, *Iterable*.\n* `HashMap#set(key, value)` Key must be primitive. Returns undefined.\n* `HashMap#get(key)` Returns the value the key corresponds to or undefined.\n* `HashMap#has(key)` Returns boolean.\n* `HashMap#delete(key)` Removes the value from the collection and returns boolean indicating if there was a value to delete.\n* `HashMap#size()` Returns the number of items in the collection.\n* `HashMap#forEach(callback, context)` Loop through the collection raising callback for each.\n\n\n### Map\n\n__All possible values__ are valid keys, including -0, undefined, null, and NaN.\n\nMaps do not have the same garbage collection benefits that WeakMaps do, but instead are iterable and also accept primitive keys. This means any value can be a Map key.\n\n* `new Map(iterable)` Create a new Map populated with the iterable. Accepts *[[Key, Value]...]*, *Array*, *Iterable*.\n* `Map#set(key, value)` Key is any value including objects. Returns undefined.\n* `Map#get(key)` Returns the value the key maps to or undefined.\n* `Map#has(key)` Returns boolean.\n* `Map#delete(key)` Removes the key and value from the collection if found. Returns true.\n* `Map#size()` Returns the number of items in the collection.\n* `Map#forEach(callback, context)` Loop through the collection raising callback for each.\n\n\n### Set\n\nSets are similar to arrays but enforce uniqueness of values. Adding the same value twice will only result in one being added to the set.\n\n* `new Set(iterable)` Create a new Set populated with the iterable. Accepts *Array*, *Iterable*.\n* `Set#add(value)` Inserts a value of any type into the set if it's not already in the set.\n* `Set#has(value)` Returns boolean.\n* `Set#delete(value)` Removes the value from the collection and returns boolean indicating if there was a value to delete.\n* `Set#size()` Returns the number of items in the collection.\n* `Set#forEach(callback, context)` Loop through the collection raising callback for each.\n\n\n\n## License\n\n(The MIT License)\nCopyright (c) 2012 Brandon Benvie <http://bbenvie.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files\n(the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included with all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\nFOR ANY  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH\nTHE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n","_id":"harmony-collections@0.3.8","dist":{"shasum":"bd2b186db808e32182121f3400abd16f2208b32a","tarball":"http://registry.npmjs.org/harmony-collections/-/harmony-collections-0.3.8.tgz"},"_npmVersion":"1.1.61","_npmUser":{"name":"benvie","email":"brandon@bbenvie.com"},"maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"directories":{}}},"readme":null,"maintainers":[{"name":"benvie","email":"brandon@bbenvie.com"}],"time":{"modified":"2012-11-09T03:30:35.898Z","created":"2011-12-15T21:57:14.065Z","0.0.1":"2011-12-15T21:57:14.819Z","0.0.2":"2011-12-15T22:11:45.242Z","0.0.3":"2011-12-15T22:33:32.850Z","0.0.4":"2011-12-15T23:08:05.405Z","0.0.5":"2011-12-16T01:08:04.343Z","0.0.6":"2011-12-16T01:57:30.452Z","0.0.7":"2011-12-16T02:21:07.638Z","0.0.8":"2011-12-16T03:13:57.415Z","0.0.9":"2011-12-16T04:22:50.705Z","0.1.0":"2011-12-16T21:40:28.653Z","0.1.1":"2011-12-17T21:18:10.358Z","0.1.2":"2011-12-21T11:54:00.082Z","0.1.3":"2011-12-25T22:12:58.850Z","0.1.4":"2011-12-26T07:54:59.119Z","0.1.5":"2011-12-26T07:59:41.746Z","0.1.6":"2011-12-27T22:11:04.791Z","0.1.7":"2011-12-27T22:27:00.839Z","0.1.8":"2011-12-27T22:29:08.308Z","0.2.0":"2011-12-27T22:41:59.118Z","0.2.1":"2012-05-03T09:51:19.309Z","0.2.2":"2012-05-03T09:55:38.741Z","0.2.3":"2012-05-03T14:35:47.930Z","0.2.4":"2012-05-03T23:01:13.500Z","0.2.5":"2012-05-07T04:00:02.092Z","0.2.6":"2012-05-09T06:17:14.917Z","0.2.9":"2012-06-25T00:27:54.687Z","0.3.1":"2012-09-23T22:06:37.375Z","0.3.2":"2012-09-23T22:07:26.768Z","0.3.3":"2012-09-23T22:34:42.985Z","0.3.4":"2012-09-24T12:54:20.728Z","0.3.5":"2012-09-24T13:04:02.839Z","0.3.6":"2012-09-25T18:23:44.750Z","0.3.7":"2012-09-28T18:58:17.451Z","0.3.8":"2012-11-09T03:30:35.898Z"},"author":{"name":"Brandon Benvie","email":"http://bbenvie.com"},"repository":{"type":"git","url":"https://github.com/Benvie/harmony-collections"},"_attachments":{},"_etag":"\"CRSLU4U8QEDX1J5ENXT7KEUXW\""}